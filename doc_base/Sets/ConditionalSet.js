// Generated by CoffeeScript 1.9.3
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _mathJS.ConditionalSet = (function(superClass) {
    var CLASS;

    extend(ConditionalSet, superClass);

    CLASS = ConditionalSet;


    /*
    {2x^2 | x in R and 0 <= x < 20 and x = x^2} ==> {0, 1}
    x in R and 0 <= x < 20 and x = x^2 <=> R intersect [0, 20) intersect {0,1} (where 0 and 1 have to be part of the previous set)
    do the following:
    1. map domains to domains
    2. map unequations to intervals
    3. map equations to (discrete?!) sets
    4. create intersection of all!
    
    simplifications:
    1.  domains intersect interval = interval (because in this notation the domain is the superset)
        so it wouldnt make sense to say: x in N and x in [0, 10] and expect the set to be infinite!!
        the order does not matter (otherwise (x in [0, 10] and x in N) would be infinite!!)
    2.  when trying to get equation solutions numerically (should this ever happen??) look for interval first to get boundaries
     */

    function ConditionalSet(expression, predicate) {
      if (arguments.length === 0) {
        this.generator = null;
      } else if (expression instanceof mathJS.Generator) {
        this.generator = expression;
      } else {
        if (predicate instanceof mathJS.Expression) {
          predicate = predicate.getSet();
        }
        this.generator = new mathJS.Generator(new mathJS.Function("f", expression, predicate, expression.getSet()), predicate.min(), predicate.max());
      }
    }

    ConditionalSet.prototype.cartesianProduct = function() {
      var generators, ref, set, sets;
      sets = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      generators = [this.generator].concat((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = sets.length; i < len; i++) {
          set = sets[i];
          results.push(set.generator);
        }
        return results;
      })());
      return new _mathJS.ConditionalSet((ref = mathJS.Generator).product.apply(ref, generators));
    };

    ConditionalSet.prototype.clone = function() {
      return new CLASS();
    };

    ConditionalSet.prototype.contains = function(elem) {
      var ref;
      if (mathJS.isComparable(elem)) {
        if (((ref = this.condition) != null ? ref.check(elem) : void 0) === true) {
          return true;
        }
      }
      return false;
    };

    ConditionalSet.prototype.equals = function(set) {
      if (set instanceof CLASS) {
        return this.generator.f.equals(set.generator.f);
      }
      return set.discreteSet.isEmpty() && this.generator.f.equals(set.conditionSet.generator.f);
    };

    ConditionalSet.prototype.getElements = function(n, sorted) {
      var res;
      res = [];
      return res;
    };

    ConditionalSet.prototype.intersection = function(set) {};

    ConditionalSet.prototype.isSubsetOf = function(set) {};

    ConditionalSet.prototype.isSupersetOf = function(set) {};

    ConditionalSet.prototype.size = function() {
      return this.generator.f.range.size();
    };

    ConditionalSet.prototype.union = function(set) {};

    ConditionalSet.prototype.without = function(set) {};

    ConditionalSet._makeAliases();

    if (DEBUG) {
      ConditionalSet.test = function() {
        var e1, e2, e3, p1, p2, p3;
        e1 = new mathJS.Expression(5);
        e2 = new mathJS.Expression(new mathJS.Variable("x", mathJS.Number));
        e3 = new mathJS.Expression("+", e1, e2);
        p1 = new mathJS.Expression(new mathJS.Variable("x", mathJS.Number));
        p2 = new mathJS.Expression(4);
        p3 = new mathJS.Expression("=", p1, p2);
        console.log(p3["eval"]({
          x: 4
        }));
        console.log(p3.getSet());
        console.log(AAA);
        return "done";
      };
    }

    return ConditionalSet;

  })(mathJS.Set);

}).call(this);
