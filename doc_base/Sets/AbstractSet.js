// Generated by CoffeeScript 1.9.3
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _mathJS.AbstractSet = (function(superClass) {
    extend(AbstractSet, superClass);

    function AbstractSet() {
      return AbstractSet.__super__.constructor.apply(this, arguments);
    }

    AbstractSet["implements"](_mathJS.Orderable, _mathJS.Poolable, _mathJS.Parseable);

    AbstractSet.fromString = function(str) {};

    AbstractSet.parse = function() {
      return this.fromString.apply(this, arguments);
    };

    AbstractSet.prototype.cartesianProduct = function(set) {};

    AbstractSet.prototype.clone = function() {};

    AbstractSet.prototype.contains = function(elem) {};

    AbstractSet.prototype.equals = function(set) {};

    AbstractSet.prototype.getElements = function() {};

    AbstractSet.prototype.infimum = function() {};

    AbstractSet.prototype.intersection = function(set) {};

    AbstractSet.prototype.isSubsetOf = function(set) {};

    AbstractSet.prototype.min = function() {};

    AbstractSet.prototype.max = function() {};

    AbstractSet.prototype.size = function() {
      return Infinity;
    };

    AbstractSet.prototype.supremum = function() {};

    AbstractSet.prototype.union = function(set) {};

    AbstractSet.prototype.intersection = function(set) {};

    AbstractSet.prototype.without = function(set) {};

    AbstractSet.prototype.complement = function(universe) {
      return universe.minus(this);
    };

    AbstractSet.prototype.disjoint = function(set) {
      return this.intersection(set).size() === 0;
    };

    AbstractSet.prototype.intersects = function(set) {
      return !this.disjoint(set);
    };

    AbstractSet.prototype.isEmpty = function() {
      return this.size() === 0;
    };

    AbstractSet.prototype.isSupersetOf = function(set) {
      return set.isSubsetOf(this);
    };

    AbstractSet.prototype.pow = function(exponent) {
      var i, j, ref, sets;
      sets = [];
      for (i = j = 0, ref = exponent; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        sets.push(this);
      }
      return this.cartesianProduct.apply(this, sets);
    };

    AbstractSet._makeAliases = function() {
      var alias, aliases, aliasesData, j, len, orig;
      aliasesData = {
        size: ["cardinality"],
        without: ["difference", "except", "minus"],
        contains: ["has"],
        intersection: ["intersect"],
        isSubsetOf: ["subsetOf"],
        isSupersetOf: ["supersetOf"],
        cartesianProduct: ["times"]
      };
      for (orig in aliasesData) {
        aliases = aliasesData[orig];
        for (j = 0, len = aliases.length; j < len; j++) {
          alias = aliases[j];
          this.prototype[alias] = this.prototype[orig];
        }
      }
      return this;
    };

    AbstractSet._makeAliases();

    return AbstractSet;

  })(_mathJS.Object);

}).call(this);
