// Generated by CoffeeScript 1.9.3
(function() {
  var cached;

  mathJS.Operation = (function() {
    function Operation(name, precedence, associativity, commutative, func, inverse, setEquivalent) {
      if (associativity == null) {
        associativity = "left";
      }
      this.name = name;
      this.precedence = precedence;
      this.associativity = associativity;
      this.commutative = commutative;
      this.func = func;
      this.arity = func.length;
      this.inverse = inverse || null;
      this.setEquivalent = setEquivalent || null;
    }

    Operation.prototype["eval"] = function(args) {
      return this.func.apply(this, args);
    };

    Operation.prototype.invert = function() {
      if (this.inverse != null) {
        return this.inverse.apply(this, arguments);
      }
      return null;
    };

    return Operation;

  })();

  mathJS.Abstract = {
    Operations: {
      divide: function(x, y) {
        if (mathJS.Number.valueIsValid(x) && mathJS.Number.valueIsValid(y)) {
          x = new mathJS.Number(x);
          y = new mathJS.Number(y);
        }
        return x.divide(y);
      },
      minus: function(x, y) {
        if (mathJS.Number.valueIsValid(x) && mathJS.Number.valueIsValid(y)) {
          x = new mathJS.Number(x);
          y = new mathJS.Number(y);
        }
        return x.minus(y);
      },
      plus: function(x, y) {
        if (mathJS.Number.valueIsValid(x) && mathJS.Number.valueIsValid(y)) {
          x = new mathJS.Number(x);
          y = new mathJS.Number(y);
        }
        return x.plus(y);
      },
      times: function(x, y) {
        if (mathJS.Number.valueIsValid(x) && mathJS.Number.valueIsValid(y)) {
          x = new mathJS.Number(x);
          y = new mathJS.Number(y);
        }
        return x.times(y);
      },
      negate: function(x) {
        if (mathJS.Number.valueIsValid(x)) {
          x = new mathJS.Number(x);
        }
        return x.negate();
      },
      unaryPlus: function(x) {
        if (mathJS.Number.valueIsValid(x)) {
          x = new mathJS.Number(x);
        }
        return x.clone();
      },
      and: function(x, y) {
        return x.and(y);
      },
      or: function(x, y) {
        return x.or(y);
      },
      not: function(x) {
        return x.not();
      },
      nand: function(x, y) {
        return x.nand(y);
      },
      nor: function(x, y) {
        return x.nor(y);
      },
      xor: function(x, y) {
        return x.xor(y);
      },
      equals: function(x, y) {
        return x.equals(y);
      }
    }
  };


  /*
  PRECEDENCE (top to bottom):
  (...)
  factorial
  unary +/-
  exponents, roots
  multiplication, division
  addition, subtraction
   */

  cached = {
    division: new mathJS.Operation("divide", 1, "left", false, mathJS.pow, mathJS.root),
    addition: new mathJS.Operation("plus", 1, "left", true, mathJS.Abstract.Operations.plus, mathJS.Abstract.Operations.minus),
    subtraction: new mathJS.Operation("plus", 1, "left", false, mathJS.Abstract.Operations.minus, mathJS.Abstract.Operations.plus),
    multiplication: new mathJS.Operation("times", 1, "left", true, mathJS.Abstract.Operations.times, mathJS.Abstract.Operations.divide),
    exponentiation: new mathJS.Operation("pow", 1, "right", false, mathJS.pow, mathJS.root),
    factorial: new mathJS.Operation("factorial", 10, "right", false, mathJS.factorial, mathJS.factorialInverse),
    negate: new mathJS.Operation("negate", 11, "none", false, mathJS.Abstract.Operations.negate, mathJS.Abstract.Operations.negate),
    unaryPlus: new mathJS.Operation("unaryPlus", 11, "none", false, mathJS.Abstract.Operations.unaryPlus, mathJS.Abstract.Operations.unaryPlus),
    and: new mathJS.Operation("and", 1, "left", true, mathJS.Abstract.Operations.and, null, "intersection"),
    or: new mathJS.Operation("or", 1, "left", true, mathJS.Abstract.Operations.or, null, "union"),
    not: new mathJS.Operation("not", 5, "none", false, mathJS.Abstract.Operations.not, mathJS.Abstract.Operations.not, "complement"),
    nand: new mathJS.Operation("nand", 1, "left", true, mathJS.Abstract.Operations.nand, null),
    nor: new mathJS.Operation("nor", 1, "left", true, mathJS.Abstract.Operations.nor, null),
    xor: new mathJS.Operation("xor", 1, "left", true, mathJS.Abstract.Operations.xor, null),
    equals: new mathJS.Operation("equals", 1, "left", true, mathJS.Abstract.Operations.equals, null, "intersection")
  };

  mathJS.Operations = {
    "+": cached.addition,
    "plus": cached.addition,
    "-": cached.subtraction,
    "minus": cached.subtraction,
    "*": cached.multiplication,
    "times": cached.multiplication,
    "/": cached.division,
    ":": cached.division,
    "divide": cached.division,
    "^": cached.exponentiation,
    "pow": cached.exponentiation,
    "!": cached.factorial,
    "negate": cached.negate,
    "-u": cached.negate,
    "u-": cached.negate,
    "unaryMinus": cached.negate,
    "neutralMinus": cached.negate,
    "+u": cached.unaryPlus,
    "u+": cached.unaryPlus,
    "unaryPlus": cached.unaryPlus,
    "neutralPlus": cached.unaryPlus,
    "and": cached.and,
    "or": cached.or,
    "not": cached.not,
    "nand": cached.nand,
    "nor": cached.nor,
    "xor": cached.xor,
    "equals": cached.equals,
    "=": cached.equals,
    "xnor": cached.equals
  };

}).call(this);
