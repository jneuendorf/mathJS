// Generated by CoffeeScript 1.9.3
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  mathJS.Utils.Dispatcher = (function(superClass) {
    extend(Dispatcher, superClass);

    Dispatcher.registeredDispatchers = mathJS.Utils.Hash["new"]();

    Dispatcher.registerDispatcher = function(newReceiver, newTargets) {
      var regReceivers, registrationPossible;
      registrationPossible = true;
      regReceivers = this.registeredDispatchers.keys;
      this.registeredDispatchers.each(function(regReceiver, regTargets, idx) {
        var i, j, len, len1, newTarget, regTarget;
        for (i = 0, len = regTargets.length; i < len; i++) {
          regTarget = regTargets[i];
          if (regTarget === newReceiver) {
            for (j = 0, len1 = newTargets.length; j < len1; j++) {
              newTarget = newTargets[j];
              if (!(regReceivers.indexOf(newTarget))) {
                continue;
              }
              registrationPossible = false;
              return false;
            }
          }
        }
        return true;
      });
      if (registrationPossible) {
        this.registeredDispatchers.put(newReceiver, newTargets);
        return this;
      }
      throw new mathJS.Errors.CycleDetectedError("Can't register '" + newReceiver + "' for dispatching - cycle detected!");
    };

    function Dispatcher(receiver, targets) {
      if (targets == null) {
        targets = [];
      }
      this.constructor.registerDispatcher(receiver, targets);
      this.receiver = receiver;
      this.targets = targets;
    }

    Dispatcher.prototype.dispatch = function() {
      var dispatch, i, len, method, params, ref, t, target;
      target = arguments[0], method = arguments[1], params = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      dispatch = false;
      if (this.targets.indexOf(target.constructor || target) >= 0) {
        dispatch = true;
      } else {
        ref = this.targets;
        for (i = 0, len = ref.length; i < len; i++) {
          t = ref[i];
          if (!(typeof target === t)) {
            continue;
          }
          dispatch = true;
          break;
        }
      }
      if (dispatch) {
        if (target[method] instanceof Function) {
          return target[method].apply(target, params);
        }
        throw new mathJS.Errors.NotImplementedError("Can't call '" + method + "' on target '" + target + "'", "Dispatcher.coffee", void 0, target);
      }
      return null;
    };

    return Dispatcher;

  })(_mathJS.Object);

}).call(this);
