// Generated by CoffeeScript 1.9.3

/**
 * This is an implementation of a dictionary/hash that does not convert its keys into Strings. Keys can therefore actually by anything!
 * @class Hash
 * @constructor
*
 */

(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  mathJS.Utils.Hash = (function() {

    /**
     * Creates a new Hash from a given JavaScript object.
     * @static
     * @method fromObject
     * @param object {Object}
    *
     */
    Hash.fromObject = function(obj) {
      return new mathJS.Utils.Hash(obj);
    };

    Hash["new"] = function(obj) {
      return new mathJS.Utils.Hash(obj);
    };

    function Hash(obj) {
      var key, val;
      this.keys = [];
      this.values = [];
      if (obj != null) {
        for (key in obj) {
          val = obj[key];
          this.put(key, val);
        }
      }
    }

    Hash.prototype.clone = function() {
      var res;
      res = new mathJS.Utils.Hash();
      res.keys = this.keys.clone();
      res.values = this.values.clone();
      return res;
    };

    Hash.prototype.invert = function() {
      var res;
      res = new mathJS.Utils.Hash();
      res.keys = this.values.clone();
      res.values = this.keys.clone();
      return res;
    };


    /**
     * Adds a new key-value pair or overwrites an existing one.
     * @method put
     * @param key {mixed}
     * @param val {mixed}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    Hash.prototype.put = function(key, val) {
      var idx;
      idx = this.keys.indexOf(key);
      if (idx < 0) {
        this.keys.push(key);
        this.values.push(val);
      } else {
        this.keys[idx] = key;
        this.values[idx] = val;
      }
      return this;
    };


    /**
     * Returns the value (or null) for the specified key.
     * @method get
     * @param key {mixed}
     * @param [equalityFunction] {Function}
     * This optional function can overwrite the test for equality between keys. This function expects the parameters: (the current key in the key iteration, 'key'). If this parameters is omitted '===' is used.
     * @return {mixed}
    *
     */

    Hash.prototype.get = function(key) {
      var idx;
      if ((idx = this.keys.indexOf(key)) >= 0) {
        return this.values[idx];
      }
      return null;
    };


    /**
     * Indicates whether the Hash has the specified key.
     * @method hasKey
     * @param key {mixed}
     * @return {Boolean}
    *
     */

    Hash.prototype.hasKey = function(key) {
      return indexOf.call(this.keys, key) >= 0;
    };

    Hash.prototype.has = function(key) {
      return this.hasKey(key);
    };


    /**
     * Returns the number of entries in the Hash.
     * @method size
     * @return {Integer}
    *
     */

    Hash.prototype.size = function() {
      return this.keys.length;
    };

    Hash.prototype.empty = function() {
      this.keys = [];
      this.values = [];
      return this;
    };

    Hash.prototype.remove = function(key) {
      var idx;
      if ((idx = this.keys.indexOf(key)) >= 0) {
        this.keys.splice(idx, 1);
        this.values.splice(idx, 1);
      } else {
        console.warn("Could not remove key '" + key + "'!");
      }
      return this;
    };

    Hash.prototype.each = function(callback) {
      var i, j, key, len, ref;
      ref = this.keys;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        key = ref[i];
        if (callback(key, this.values[i], i) === false) {
          return this;
        }
      }
      return this;
    };

    return Hash;

  })();

}).call(this);
