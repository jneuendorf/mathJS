// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  mathJS.Domains.N = (function(_super) {
    var CLASS;

    __extends(N, _super);

    CLASS = N;

    function N() {
      Object.defineProperties(this, {
        generator: {
          value: function(n) {
            return n;
          },
          writable: false,
          enumerable: false,
          configurable: false
        },
        expression: {
          value: function(x) {
            return x;
          },
          writable: false,
          enumerable: false,
          configurable: false
        },
        isCountable: {
          value: true,
          enumerable: true,
          writable: false,
          configurable: false
        },
        size: {
          value: Infinity,
          enumerable: true,
          writable: false,
          configurable: false
        },
        isMutable: {
          value: false,
          writable: false,
          enumerable: false,
          configurable: false
        },
        leftBoundary: {
          value: {
            value: -Infinity,
            open: true
          },
          writable: false,
          enumerable: false,
          configurable: false
        },
        rightBoundary: {
          value: {
            value: +Infinity,
            open: true
          },
          writable: false,
          enumerable: false,
          configurable: false
        }
      });
    }

    N.contains = function(x) {
      return mathJS.isInt(x) || new mathJS.Int(x).equals(x);
    };

    N.prototype.contains = CLASS.contains;

    N.prototype.clone = function() {
      return new mathJS.Domains.N();
    };

    N.prototype.equals = function(set, n) {
      var generator, i, val;
      if (n == null) {
        n = mathJS.settings.set.maxIterations * 10;
      }
      if (this._isSet(set)) {
        if (set.size === Infinity) {
          generator = this.generator;
          i = 0;
          while (i++ < n) {
            val = generator(i);
            if (!set.contains(val)) {
              return false;
            }
            if (DEBUG) {
              console.log("japp");
            }
          }
          return true;
        }
        return false;
      }
      return false;
    };


    /**
    * This method checks if `this` is a subset of the given set `set`. Since equality must be checked by checking an arbitrary number of values this method actually does the same as `this.equals()`. For `this.equals()` the number of compared elements is 10x bigger.
    *
     */

    N.prototype.isSubsetOf = function(set, n) {
      if (n == null) {
        n = mathJS.settings.set.maxIterations;
      }
      return this.equals(set, n * 10);
    };

    N.prototype.isSupersetOf = function(set) {
      if (this._isSet(set)) {
        return set.isSubsetOf(this);
      }
      return false;
    };

    N.prototype.union = function(set, n, matches) {
      var checker, self;
      if (n == null) {
        n = mathJS.settings.set.maxIterations;
      }
      if (matches == null) {
        matches = mathJS.settings.set.maxMatches;
      }
      checker = function(elem) {
        return self.checker(elem) || set.checker(elem);
      };
      if (set instanceof mathJS.DiscreteSet || (typeof set["instanceof"] === "function" ? set["instanceof"](mathJS.DiscreteSet) : void 0)) {

      } else if (set instanceof mathJS.Set || (typeof set["instanceof"] === "function" ? set["instanceof"](mathJS.Set) : void 0)) {
        if (mathJS["instanceof"](set, mathJS.Domains.N)) {
          return this;
        }
        if (mathJS["instanceof"](set, mathJS.Domains.Q) || mathJS["instanceof"](set, mathJS.Domains.R)) {
          return set;
        }
        self = this;
      }
      return null;
    };

    N.prototype.intersect = function(set) {
      var checker, commonElements, elem, f1, f1Elem, f1Elems, f2, f2Elem, f2Elems, found, i, m, ops, x, y1, y2, _i, _j, _k, _len, _len1, _len2;
      checker = function(elem) {
        return self.checker(elem) && set.checker(elem);
      };
      commonElements = [];
      x = 0;
      m = 0;
      f1 = this.generator;
      f2 = set.generator;
      f1Elems = [];
      f2Elems = [];
      while (x < n && m < matches) {
        y1 = f1(x);
        y2 = f2(x);
        if (mathJS.gt(y1, y2)) {
          found = false;
          for (i = _i = 0, _len = f1Elems.length; _i < _len; i = ++_i) {
            f1Elem = f1Elems[i];
            if (!(mathJS.equals(y2, f1Elem))) {
              continue;
            }
            m++;
            found = true;
            commonElements.push(y2);
            f1Elems = f1Elems.slice(i + 1);
            f2Elems = [];
            break;
          }
          if (!found) {
            f1Elems.push(y1);
            f2Elems.push(y2);
          }
        } else if (mathJS.lt(y1, y2)) {
          found = false;
          for (i = _j = 0, _len1 = f2Elems.length; _j < _len1; i = ++_j) {
            f2Elem = f2Elems[i];
            if (!(mathJS.equals(y1, f2Elem))) {
              continue;
            }
            m++;
            found = true;
            commonElements.push(y1);
            f2Elems = f2Elems.slice(i + 1);
            f1Elems = [];
            break;
          }
          if (!found) {
            f1Elems.push(y1);
            f2Elems.push(y2);
          }
        } else {
          m++;
          commonElements.push(y1);
          f1Elems = [];
          f2Elems = [];
        }
        x++;
      }
      console.log("x=" + x, "m=" + m, commonElements);
      ops = [];
      for (_k = 0, _len2 = commonElements.length; _k < _len2; _k++) {
        elem = commonElements[_k];
        true;
      }
    };

    N.prototype.intersects = function(set) {
      return this.intersection(set).size > 0;
    };

    N.prototype.disjoint = function(set) {
      return this.intersection(set).size === 0;
    };

    N.prototype.complement = function() {
      if (this.universe != null) {
        return this.universe.without(this);
      }
      return new mathJS.EmptySet();
    };


    /**
    * a.without b => returns: removed all common elements from a
    *
     */

    N.prototype.without = function(set) {};

    N.prototype.cartesianProduct = function(set) {};

    N.prototype.times = N.prototype.cartesianProduct;

    return N;

  })(mathJS.Set);

  (function() {
    var clss;
    clss = mathJS.Domains.N;
    mathJS.Domains.N = new mathJS.Domains.N();
    return mathJS.Domains.N["new"] = function() {
      return new clss();
    };
  })();

}).call(this);
