// Generated by CoffeeScript 1.9.3
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _mathJS.AbstractNumber = (function(superClass) {
    extend(AbstractNumber, superClass);

    function AbstractNumber() {
      return AbstractNumber.__super__.constructor.apply(this, arguments);
    }

    AbstractNumber["implements"](_mathJS.Orderable, _mathJS.Poolable, _mathJS.Parseable);


    /**
    * @Override mathJS.Poolable
    * @static
    * @method _fromPool
    *
     */

    AbstractNumber._fromPool = function(value) {
      var number, val;
      if (this._pool.length > 0) {
        if ((val = this._getPrimitive(value)) != null) {
          number = this._pool.pop();
          number.value = val.value || val;
          return number;
        }
        throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + value + "'", "AbstractNumber.coffee", void 0, value);
      }
      return new this(value);
    };


    /**
    * @Override mathJS.Parseable
    * @static
    * @method parse
    *
     */

    AbstractNumber.parse = function(str) {
      return this._fromPool(parseFloat(str));
    };

    AbstractNumber.getSet = function() {
      throw new mathJS.Errors.NotImplementedError("getSet in " + this.name);
    };

    AbstractNumber["new"] = function(param) {
      return this._fromPool(param);
    };

    AbstractNumber.random = function(max, min) {
      return this._fromPool(mathJS.randNum(max, min));
    };

    AbstractNumber.dispatcher = new mathJS.Utils.Dispatcher(AbstractNumber, ["string"]);


    /**
    * This method is used to parse and check a parameter.
    * Either a valid value is returned or null (for invalid parameters).
    * @static
    * @method _getPrimitive
    * @param param {Object}
    * @param skipCheck {Boolean}
    * @return {mathJS.Number}
    *
     */

    AbstractNumber._getPrimitive = function(param, skipCheck) {
      return null;
    };

    AbstractNumber.prototype._setValue = function(value) {
      return this;
    };

    AbstractNumber.prototype._getValue = function() {
      return this._value;
    };

    AbstractNumber.prototype._getPrimitive = function(param) {
      return this.constructor._getPrimitive(param);
    };


    /**
    * @Override mathJS.Comparable
    * This method checks for mathmatical equality. This means new mathJS.Double(4.2).equals(4.2) is true.
    * @method equals
    * @param {Number} n
    * @return {Boolean}
    *
     */

    AbstractNumber.prototype.equals = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return this.value === val;
      }
      return false;
    };


    /**
    * @Override mathJS.Orderable
    * This method checks for mathmatical "<". This means new mathJS.Double(4.2).lessThan(5.2) is true.
    * @method lessThan
    *
     */

    AbstractNumber.prototype.lessThan = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return this.value < val;
      }
      return false;
    };


    /**
    * @Override mathJS.Orderable
    * This method checks for mathmatical ">". This means new mathJS.Double(4.2).greaterThan(3.2) is true.
    * @method greaterThan
    * @param {Number} n
    * @return {Boolean}
    *
     */

    AbstractNumber.prototype.greaterThan = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return this.value > val;
      }
      return false;
    };


    /**
    * @Override mathJS.Orderable
    * This method checks for mathmatical "<=".
    * @method lessThanOrEqualTo
    * @param {Number} n
    * @return {Boolean}
    *
     */

    AbstractNumber.prototype.lessThanOrEqualTo = function(n) {
      return this.lessThan(n) || this.equals(n);
    };


    /**
    * This method checks for mathmatical ">=".
    * @method greaterThanOrEqualTo
    * @param {Number} n
    * @return {Boolean}
    *
     */

    AbstractNumber.prototype.greaterThanOrEqualTo = function(n) {
      return this.greaterThan(n) || this.equals(n);
    };


    /**
    * This method adds 2 numbers and returns a new one.
    * @method plus
    * @param {Number} n
    * @return {mathJS.Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.plus = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return mathJS.Number["new"](this.value + val);
      }
      throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + n + "'", "AbstractNumber.coffee", void 0, n);
    };


    /**
    * This method substracts 2 numbers and returns a new one.
    * @method minus
    * @param {Number} n
    * @return {mathJS.Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.minus = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return mathJS.Number["new"](this.value - val);
      }
      throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + n + "'", "AbstractNumber.coffee", void 0, n);
    };


    /**
    * This method multiplies 2 numbers and returns a new one.
    * @method times
    * @param {Number} n
    * @return {mathJS.Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.times = function(n) {
      var result, val;
      if ((result = this.constructor.dispatcher.dispatch(n, "times", this)) != null) {
        return result;
      }
      if ((val = this._getPrimitive(n)) != null) {
        return mathJS.Number["new"](this.value * val);
      }
      throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + n + "'", "AbstractNumber.coffee", void 0, n);
    };


    /**
    * This method divides 2 numbers and returns a new one.
    * @method divide
    * @param {Number} n
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.divide = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return mathJS.Number["new"](this.value / val);
      }
      throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + n + "'", "AbstractNumber.coffee", void 0, n);
    };


    /**
    * This method squares this instance and returns a new one.
    * @method square
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.square = function() {
      return mathJS.Number["new"](this.value * this.value);
    };


    /**
    * This method cubes this instance and returns a new one.
    * @method cube
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.cube = function() {
      return mathJS.Number["new"](this.value * this.value * this.value);
    };


    /**
    * This method calculates the square root of this instance and returns a new one.
    * @method sqrt
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.sqrt = function() {
      return mathJS.Number["new"](mathJS.sqrt(this.value));
    };


    /**
    * This method calculates the cubic root of this instance and returns a new one.
    * @method curt
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.curt = function() {
      return this.pow(0.3333333333333333);
    };


    /**
    * This method calculates any root of this instance and returns a new one.
    * @method root
    * @param {Number} exponent
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.root = function(exp) {
      var val;
      if ((val = this._getPrimitive(exp)) != null) {
        return this.pow(1 / val);
      }
      throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + exp + "'", "AbstractNumber.coffee", void 0, exp);
    };


    /**
    * This method returns the reciprocal (1/n) of this number.
    * @method reciprocal
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.reciprocal = function() {
      return mathJS.Number["new"](1 / this.value);
    };


    /**
    * This method returns this' value the the n-th power (this^n).
    * @method pow
    * @param {Number} n
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.pow = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return mathJS.Number["new"](mathJS.pow(this.value, val));
      }
      throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + n + "'", "AbstractNumber.coffee", void 0, n);
    };


    /**
    * This method returns the sign of this number (sign(this)).
    * @method sign
    * @param plain {Boolean}
    * Indicates whether the return value is wrapped in a mathJS.Number or not (-> primitive value).
    * @return {Number|mathJS.Number}
    *
     */

    AbstractNumber.prototype.sign = function(plain) {
      var val;
      if (plain == null) {
        plain = true;
      }
      val = this.value;
      if (plain === true) {
        if (val < 0) {
          return -1;
        }
        return 1;
      }
      if (val < 0) {
        return mathJS.Number["new"](-1);
      }
      return mathJS.Number["new"](1);
    };

    AbstractNumber.prototype.negate = function() {
      return mathJS.Number["new"](-this.value);
    };

    AbstractNumber.prototype.toInt = function() {
      return mathJS.Int["new"](this.value);
    };

    AbstractNumber.prototype.toNumber = function() {
      return mathJS.Number["new"](this.value);
    };

    AbstractNumber.prototype.toString = function(format) {
      if (format == null) {
        return "" + this.value;
      }
      return numeral(this.value).format(format);
    };

    AbstractNumber.prototype.clone = function() {
      return mathJS.Number["new"](this.value);
    };

    AbstractNumber.prototype["eval"] = function(values) {
      return this;
    };

    AbstractNumber.prototype._getSet = function() {
      return new mathJS.Set(this);
    };

    AbstractNumber.prototype["in"] = function(set) {
      return set.contains(this);
    };

    return AbstractNumber;

  })(_mathJS.Object);

}).call(this);
