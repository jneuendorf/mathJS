// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  mathJS.Vector = (function() {
    Vector.prototype._isVectorLike = function(v) {
      return v instanceof mathJS.Vector || (typeof v["instanceof"] === "function" ? v["instanceof"](mathJS.Vector) : void 0) || v instanceof mathJS.Tuple || (typeof v["instanceof"] === "function" ? v["instanceof"](mathJS.Tuple) : void 0);
    };

    Vector._isVectorLike = Vector.prototype._isVectorLike;

    function Vector(values) {
      var val, _i, _len;
      this.values = values;
      if (DEBUG) {
        for (_i = 0, _len = values.length; _i < _len; _i++) {
          val = values[_i];
          if (!mathJS.isMathJSNum(val)) {
            console.warn("invalid value:", val);
          }
        }
      }
    }

    Vector.prototype.equals = function(v) {
      var i, vValue, val, _i, _len, _ref;
      if (!this._isVectorLike(v)) {
        return false;
      }
      _ref = this.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        val = _ref[i];
        vValue = v.values[i];
        if (!(typeof val.equals === "function" ? val.equals(vValue) : void 0) && val !== vValue) {
          return false;
        }
      }
      return true;
    };

    Vector.prototype.clone = function() {
      return new TD.Vector(this.values);
    };

    Vector.prototype.move = function(v) {
      var i, vValue, val, _i, _len, _ref;
      if (!this._isVectorLike(v)) {
        return this;
      }
      _ref = v.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        val = _ref[i];
        vValue = v.values[i];
        this.values[i] = (typeof vValue.plus === "function" ? vValue.plus(val) : void 0) || (typeof val.plus === "function" ? val.plus(vValue) : void 0) || (vValue + val);
      }
      return this;
    };

    Vector.prototype.moveBy = Vector.move;

    Vector.prototype.moveTo = function(p) {
      var i, vValue, val, _i, _len, _ref;
      if (!this._isVectorLike(v)) {
        return this;
      }
      _ref = v.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        val = _ref[i];
        vValue = v.values[i];
        this.values[i] = vValue.value || vValue;
      }
      return this;
    };

    Vector.prototype.multiply = function(r) {
      if (Math.isNum(r)) {
        return new TD.Point(this.x * r, this.y * r);
      }
      return null;
    };

    Vector.prototype.times = Vector.multiply;

    Vector.prototype.magnitude = function() {
      var i, sum, val, _i, _len, _ref;
      sum = 0;
      _ref = this.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        val = _ref[i];
        sum += val * val;
      }
      return Math.sqrt(sum);
    };


    /**
     * This method calculates the distance between 2 points.
     * It's a shortcut for substracting 2 vectors and getting that vector's magnitude (because no new object is created).
     * For that reason this method should be used for pure distance calculations.
     *
     * @method distanceTo
     * @param {Point} p
     * @return {Number} Distance between this point and p.
    *
     */

    Vector.prototype.distanceTo = function(v) {
      var i, sum, val, _i, _len, _ref;
      sum = 0;
      _ref = this.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        val = _ref[i];
        sum += (val - v.values[i]) * (val - v.values[i]);
      }
      return Math.sqrt(sum);
    };

    Vector.prototype.add = function(v) {
      var i, vValue, val, values, _i, _len, _ref;
      if (!this._isVectorLike(v)) {
        return null;
      }
      values = [];
      _ref = v.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        val = _ref[i];
        vValue = v.values[i];
        values.push((typeof vValue.plus === "function" ? vValue.plus(val) : void 0) || (typeof val.plus === "function" ? val.plus(vValue) : void 0) || (vValue + val));
      }
      return new mathJS.Vector(values);
    };

    Vector.prototype.plus = Vector.add;

    Vector.prototype.substract = function(p) {
      if (isPointLike(p)) {
        return new TD.Point(this.x - p.x, this.y - p.y);
      }
      return null;
    };

    Vector.prototype.minus = Vector.substract;

    Vector.prototype.xyRatio = function() {
      return this.x / this.y;
    };

    Vector.prototype.toArray = function() {
      return [this.x, this.y];
    };

    Vector.prototype.isPositive = function() {
      return this.x >= 0 && this.y >= 0;
    };


    /**
     * Returns the angle of a vector. Beware that the angle is measured in counter clockwise direction beginning at 0˚ which equals the x axis in positive direction.
     * So on a computer grid the angle won't be what you expect! Use anglePC() in that case!
     *
     * @method angle
     * @return {Number} Angle of the vector in degrees. 0 degrees means pointing to the right.
    *
     */

    Vector.prototype.angle = function() {
      if (this.x >= 0 && this.y >= 0) {
        return Math.radToDeg(Math.atan(Math.abs(this.y) / Math.abs(this.x))) % 360;
      }
      if (this.x < 0 && this.y > 0) {
        return (90 + Math.radToDeg(Math.atan(Math.abs(this.x) / Math.abs(this.y)))) % 360;
      }
      if (this.x < 0 && this.y < 0) {
        return (180 + Math.radToDeg(Math.atan(Math.abs(this.y) / Math.abs(this.x)))) % 360;
      }
      return (270 + Math.radToDeg(Math.atan(Math.abs(this.x) / Math.abs(this.y)))) % 360;
    };


    /**
     * Returns the angle of a vector. 0˚ means pointing to the top. Clockwise.
     *
     * @method anglePC
     * @return {Number} Angle of the vector in degrees. 0 degrees means pointing to the right.
    *
     */

    Vector.prototype.anglePC = function() {
      if (this.x >= 0 && this.y >= 0) {
        return (90 + Math.radToDeg(Math.atan(Math.abs(this.y) / Math.abs(this.x)))) % 360;
      }
      if (this.x < 0 && this.y > 0) {
        return (180 + Math.radToDeg(Math.atan(Math.abs(this.x) / Math.abs(this.y)))) % 360;
      }
      if (this.x < 0 && this.y < 0) {
        return (270 + Math.radToDeg(Math.atan(Math.abs(this.y) / Math.abs(this.x)))) % 360;
      }
      return Math.radToDeg(Math.atan(Math.abs(this.x) / Math.abs(this.y))) % 360;
    };


    /**
     * Returns a random Point within a given radius.
     *
     * @method randPointInRadius
     * @param {Number} radius
     * Default is 10 (pixels). Must not be smaller than 0.
     * @param {Boolean} random
     * Indicates whether the given radius is the maximum or exact distance between the 2 points.
     * @return {Number} Random Point.
    *
     */

    Vector.prototype.randPointInRadius = function(radius, random) {
      var angle, x, y;
      if (radius == null) {
        radius = 5;
      }
      if (random == null) {
        random = false;
      }
      angle = Math.degToRad(Math.randNum(0, 360));
      if (random === true) {
        radius = Math.randNum(0, radius);
      }
      x = radius * Math.cos(angle);
      y = radius * Math.sin(angle);
      return this.add(new TD.Point(x, y));
    };

    return Vector;

  })();

  mathJS.Tuple = (function(_super) {
    __extends(Tuple, _super);

    function Tuple() {
      return Tuple.__super__.constructor.apply(this, arguments);
    }

    return Tuple;

  })(mathJS.Vector);

}).call(this);
