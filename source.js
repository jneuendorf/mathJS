// Generated by CoffeeScript 1.8.0

/**
 * @module mathJS
 * @main mathJS
*
 */

(function() {
  var __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  if (typeof DEBUG === "undefined") {
    window.DEBUG = true;
  }

  window.mathJS = {
    Domains: {}
  };

  window.mixOf = function() {
    var Mixed, base, method, mixin, mixins, name, superClasses, _i, _ref;
    base = arguments[0], mixins = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    Mixed = (function(_super) {
      __extends(Mixed, _super);

      function Mixed() {
        return Mixed.__super__.constructor.apply(this, arguments);
      }

      return Mixed;

    })(base);
    for (_i = mixins.length - 1; _i >= 0; _i += -1) {
      mixin = mixins[_i];
      for (name in mixin) {
        method = mixin[name];
        Mixed[name] = method;
      }
      _ref = mixin.prototype;
      for (name in _ref) {
        method = _ref[name];
        Mixed.prototype[name] = method;
      }
    }
    superClasses = Array.prototype.slice.call(arguments, 0);
    Mixed.prototype["instanceof"] = function(cls) {
      var c, _j, _len;
      if (this instanceof cls) {
        return true;
      }
      for (_j = 0, _len = superClasses.length; _j < _len; _j++) {
        c = superClasses[_j];
        if (c === cls) {
          return true;
        }
      }
      return false;
    };
    return Mixed;
  };

  Array.prototype.reverseCopy = function() {
    var item, res, _i;
    res = [];
    for (_i = this.length - 1; _i >= 0; _i += -1) {
      item = this[_i];
      res.push(item);
    }
    return res;
  };

  Array.prototype.sample = function(n, forceArray) {
    var arr, elem, i, res;
    if (n == null) {
      n = 1;
    }
    if (forceArray == null) {
      forceArray = false;
    }
    if (n === 1) {
      if (!forceArray) {
        return this[Math.floor(Math.random() * this.length)];
      }
      return [this[Math.floor(Math.random() * this.length)]];
    }
    if (n > this.length) {
      n = this.length;
    }
    i = 0;
    res = [];
    arr = this.clone();
    while (i++ < n) {
      console.log(arr);
      elem = arr.sample(1);
      res.push(elem);
      arr.remove(elem);
    }
    return res;
  };

  Array.prototype.shuffle = function() {
    var arr, elem, i, _i, _len;
    arr = this.sample(this.length);
    for (i = _i = 0, _len = arr.length; _i < _len; i = ++_i) {
      elem = arr[i];
      this[i] = elem;
    }
    return this;
  };

  Array.prototype.first = function() {
    return this[0];
  };

  Array.prototype.last = function() {
    return this[this.length - 1];
  };

  Array.prototype.average = function() {
    var elem, elems, sum, _i, _len;
    sum = 0;
    elems = 0;
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      elem = this[_i];
      if (!(Math.isNum(elem))) {
        continue;
      }
      sum += elem;
      elems++;
    }
    return sum / elems;
  };

  Array.prototype.median = Array.prototype.average;

  Array.prototype.clone = Array.prototype.slice;

  Array.prototype.remove = function(elem) {
    var idx;
    idx = this.indexOf(elem);
    if (idx > -1) {
      this.splice(idx, 1);
    }
    return this;
  };

  Array.prototype.removeAll = function(elements) {
    var elem, _i, _len;
    if (elements == null) {
      elements = [];
    }
    for (_i = 0, _len = elements.length; _i < _len; _i++) {
      elem = elements[_i];
      this.remove(elem);
    }
    return this;
  };

  Array.prototype.removeAt = function(idx) {
    this.splice(idx, 1);
    return this;
  };


  /**
   * @method getMax
   * @param {Function} propertyGetter
   * The passed callback extracts the value being compared from the array elements.
   * @return {Array} An array of all maxima.
  *
   */

  Array.prototype.getMax = function(propertyGetter) {
    var elem, max, res, val, _i, _len;
    max = null;
    res = [];
    if (propertyGetter == null) {
      propertyGetter = function(item) {
        return item;
      };
    }
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      elem = this[_i];
      val = propertyGetter(elem);
      if (val > max || max === null) {
        max = val;
        res = [elem];
      } else if (val === max) {
        res.push(elem);
      }
    }
    return res;
  };

  Array.prototype.getMin = function(propertyGetter) {
    var elem, min, res, val, _i, _len;
    min = null;
    res = [];
    if (propertyGetter == null) {
      propertyGetter = function(item) {
        return item;
      };
    }
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      elem = this[_i];
      val = propertyGetter(elem);
      if (val < min || min === null) {
        min = val;
        res = [elem];
      } else if (val === min) {
        res.push(elem);
      }
    }
    return res;
  };

  Array.prototype.sortProp = function(getProp, order) {
    var cmpFunc;
    if (order == null) {
      order = "asc";
    }
    if (getProp == null) {
      getProp = function(item) {
        return item;
      };
    }
    if (order === "asc") {
      cmpFunc = function(a, b) {
        a = getProp(a);
        b = getProp(b);
        if (a < b) {
          return -1;
        }
        if (b > a) {
          return 1;
        }
        return 0;
      };
    } else {
      cmpFunc = function(a, b) {
        a = getProp(a);
        b = getProp(b);
        if (a > b) {
          return -1;
        }
        if (b < a) {
          return 1;
        }
        return 0;
      };
    }
    return this.sort(cmpFunc);
  };

  String.prototype.camel = function(spaces) {
    var i, str, _i, _ref;
    if (spaces == null) {
      spaces = false;
    }
    str = this.toLowerCase();
    if (spaces) {
      str = str.split(" ");
      for (i = _i = 1, _ref = str.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        str[i] = str[i].charAt(0).toUpperCase() + str[i].substr(1);
      }
      str = str.join("");
    }
    return str;
  };

  String.prototype.antiCamel = function() {
    var i, res, temp, _i, _ref;
    res = this.charAt(0);
    for (i = _i = 1, _ref = this.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
      temp = this.charAt(i);
      if (temp === temp.toUpperCase()) {
        res += " ";
      }
      res += temp;
    }
    return res;
  };

  String.prototype.firstToUpperCase = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  };

  String.prototype.snakeToCamelCase = function() {
    var char, prevChar, res, _i, _len;
    res = "";
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      char = this[_i];
      if (char !== "_") {
        if (prevChar !== "_") {
          res += char;
        } else {
          res += char.toUpperCase();
        }
      }
      prevChar = char;
    }
    return res;
  };

  String.prototype.camelToSnakeCase = function() {
    var char, prevChar, res, _i, _len;
    res = "";
    prevChar = null;
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      char = this[_i];
      if (char === char.toLowerCase()) {
        res += char;
      } else {
        if (prevChar === prevChar.toLowerCase()) {
          res += "_" + char.toLowerCase();
        } else {
          res += char;
        }
      }
      prevChar = char;
    }
    return res;
  };

  Object.defineProperties(mathJS, {
    e: {
      value: Math.E,
      writable: false
    },
    pi: {
      value: Math.PI,
      writable: false
    },
    ln2: {
      value: Math.LN2,
      writable: false
    },
    ln10: {
      value: Math.LN10,
      writable: false
    },
    log2e: {
      value: Math.LOG2E,
      writable: false
    },
    log10e: {
      value: Math.LOG10E,
      writable: false
    },
    infty: {
      value: Infinity,
      writable: false
    },
    infinity: {
      value: Infinity,
      writable: false
    },
    epsilon: {
      value: Number.EPSILON,
      writable: false
    },
    maxValue: {
      value: Number.MAX_VALUE,
      writable: false
    },
    minValue: {
      value: Number.MIN_VALUE,
      writable: false
    }
  });

  mathJS.isPrimitive = function(x) {
    return typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  };

  mathJS.isComparable = function(x) {
    return x.equals instanceof Function || mathJS.isPrimitive(x);
  };

  mathJS["instanceof"] = function(instance, clss) {
    return instance instanceof clss || (typeof instance["instanceof"] === "function" ? instance["instanceof"](clss) : void 0);
  };

  mathJS.equals = function(x, y) {
    return (typeof x.equals === "function" ? x.equals(y) : void 0) || (typeof y.equals === "function" ? y.equals(x) : void 0) || x === y;
  };

  mathJS.greaterThan = function(x, y) {
    return (typeof x.gt === "function" ? x.gt(y) : void 0) || (typeof y.lt === "function" ? y.lt(x) : void 0) || x > y;
  };

  mathJS.gt = mathJS.greaterThan;

  mathJS.lessThan = function(x, y) {
    return (typeof x.lt === "function" ? x.lt(y) : void 0) || (typeof y.gt === "function" ? y.gt(x) : void 0) || x < y;
  };

  mathJS.lt = mathJS.lessThan;

  mathJS.ggT = function() {
    var ggt, i, vals, _i, _ref;
    if (arguments[0] instanceof Array) {
      vals = arguments[0];
    } else {
      vals = Array.prototype.slice.apply(arguments);
    }
    if (vals.length === 2) {
      if (vals[1] === 0) {
        return vals[0];
      }
      return mathJS.ggT(vals[1], __modulo(vals[0], vals[1]));
    } else if (vals.length > 2) {
      ggt = mathJS.ggT(vals[0], vals[1]);
      for (i = _i = 2, _ref = vals.length; 2 <= _ref ? _i < _ref : _i > _ref; i = 2 <= _ref ? ++_i : --_i) {
        ggt = mathJS.ggT(ggt, vals[i]);
      }
      return ggt;
    }
    return null;
  };

  mathJS.gcd = mathJS.ggT;

  mathJS.kgV = function() {
    var i, kgv, vals, _i, _ref;
    if (arguments[0] instanceof Array) {
      vals = arguments[0];
    } else {
      vals = Array.prototype.slice.apply(arguments);
    }
    if (vals.length === 2) {
      return Math.floor(vals[0] * vals[1] / mathJS.ggT(vals[0], vals[1]));
    } else if (vals.length > 2) {
      kgv = mathJS.kgV(vals[0], vals[1]);
      for (i = _i = 2, _ref = vals.length; 2 <= _ref ? _i < _ref : _i > _ref; i = 2 <= _ref ? ++_i : --_i) {
        kgv = mathJS.kgV(kgv, vals[i]);
      }
      return kgv;
    }
    return null;
  };

  mathJS.lcm = mathJS.kgV;

  mathJS.coprime = function(x, y) {
    return mathJS.gcd(x, y) === 1;
  };

  mathJS.ceil = Math.ceil;

  mathJS.floor = function(n) {
    return ~~n;
  };

  mathJS.floatToInt = mathJS.floor;

  mathJS.square = function(n) {
    if (mathJS.isNum(n)) {
      return n * n;
    }
    return NaN;
  };

  mathJS.cube = function(n) {
    if (mathJS.isNum(n)) {
      return n * n * n;
    }
    return NaN;
  };

  mathJS.pow = Math.pow;

  mathJS.sqrt = Math.sqrt;

  mathJS.curt = function(n) {
    if (mathJS.isNum(n)) {
      return mathJS.pow(n, 1 / 3);
    }
    return NaN;
  };

  mathJS.root = function(n, exp) {
    if (mathJS.isNum(n) && mathJS.isNum(exp)) {
      return mathJS.pow(n, 1 / exp);
    }
    return NaN;
  };

  mathJS.parseNumber = function(str) {
    return null;
  };


  /**
   * This function checks if a given parameter is a (plain) number.
   * @method isNum
   * @param {Number} num
   * @return {Boolean} Whether the given number is a Number (excluding +/-Infinity)
  *
   */

  mathJS.isNum = function(n) {
    return (n != null) && isFinite(n);
  };

  mathJS.isMathJSNum = function(n) {
    return (n != null) && (isFinite(n) || n instanceof mathJS.Number || n["instanceof"](mathJS.Number));
  };

  mathJS.isInt = function(r) {
    return mathJS.isNum(r) && ~~r === r;
  };


  /**
   * This function returns a random (plain) integer between max and min (both inclusive). If max is less than min the parameters are swapped.
   * @method randInt
   * @param {Number} max
   * @param {Number} min
   * @return {Number} Random integer.
  *
   */

  mathJS.randInt = function(max, min) {
    var temp;
    if (max == null) {
      max = 1;
    }
    if (min == null) {
      min = 0;
    }
    if (min > max) {
      temp = min;
      min = max;
      max = temp;
    }
    return Math.floor(Math.random() * (max + 1 - min)) + min;
  };


  /**
   * This function returns a random number between max and min (both inclusive). If max is less than min the parameters are swapped.
   * @method randNum
   * @param {Number} max
   * @param {Number} min
   * Default is 0.
   * @return {Integer} Random number.
  *
   */

  mathJS.randNum = function(max, min) {
    var temp;
    if (max == null) {
      max = 1;
    }
    if (min == null) {
      min = 0;
    }
    if (min > max) {
      temp = min;
      min = max;
      max = temp;
    }
    return Math.random() * (max + 1 - min) + min;
  };

  mathJS.radToDeg = function(rad) {
    return rad * 57.29577951308232;
  };

  mathJS.degToRad = function(deg) {
    return deg * 0.017453292519943295;
  };

  mathJS.sign = function(n) {
    if (mathJS.isNum(n)) {
      if (n < 0) {
        return -1;
      }
      return 1;
    }
    return NaN;
  };

  mathJS.log = function(n, base) {
    if (base == null) {
      base = 10;
    }
    return Math.log(n) / Math.log(base);
  };

  mathJS.logBase = mathJS.log;

  mathJS.reciprocal = function(n) {
    if (mathJS.isNum(n)) {
      return 1 / n;
    }
    return NaN;
  };

  mathJS.settings = {
    set: {
      maxIterations: 1000,
      maxMatches: 60
    }
  };

  mathJS.Comparable = (function() {
    function Comparable() {}


    /**
    * This method checks for mathmatical equality. This means new mathJS.Double(4.2).equals(4.2) is true.
    * @method equals
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Comparable.prototype.equals = function(n) {
      throw new Error("To be implemented!");
    };

    Comparable.prototype.e = Comparable.prototype.equals;

    return Comparable;

  })();

  mathJS.Orderable = (function(_super) {
    __extends(Orderable, _super);

    function Orderable() {
      return Orderable.__super__.constructor.apply(this, arguments);
    }


    /**
    * This method checks for mathmatical '<'. This means new mathJS.Double(4.2).lessThan(5.2) is true.
    * @method lessThan
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Orderable.prototype.lessThan = function(n) {
      throw new Error("To be implemented!");
    };


    /**
    * Alias for `lessThan`.
    * @method lt
    *
     */

    Orderable.prototype.lt = Orderable.prototype.lessThan;


    /**
    * This method checks for mathmatical '>'. This means new mathJS.Double(4.2).greaterThan(3.2) is true.
    * @method greaterThan
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Orderable.prototype.greaterThan = function(n) {
      throw new Error("To be implemented!");
    };


    /**
    * Alias for `greaterThan`.
    * @method lt
    *
     */

    Orderable.prototype.gt = Orderable.prototype.greaterThan;


    /**
    * This method checks for mathmatical '<='. This means new mathJS.Double(4.2).lessThanOrEqualTo(5.2) is true.
    * @method lessThanOrEqualTo
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Orderable.prototype.lessThanOrEqualTo = function(n) {
      throw new Error("To be implemented!");
    };


    /**
    * Alias for `lessThanOrEqualTo`.
    * @method lt
    *
     */

    Orderable.prototype.lte = Orderable.prototype.lessThanOrEqualTo;


    /**
    * This method checks for mathmatical '>='. This means new mathJS.Double(4.2).greaterThanOrEqualTo(3.2) is true.
    * @method greaterThanOrEqualTo
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Orderable.prototype.greaterThanOrEqualTo = function(n) {
      throw new Error("To be implemented!");
    };


    /**
    * Alias for `greaterThanOrEqualTo`.
    * @method lt
    *
     */

    Orderable.prototype.gte = Orderable.prototype.greaterThanOrEqualTo;

    return Orderable;

  })(mathJS.Comparable);

  mathJS.Parseable = (function() {
    function Parseable() {}

    Parseable.parse = function(str) {
      throw new Error("To be implemented");
    };

    Parseable.prototype.toString = function(args) {
      throw new Error("To be implemented");
    };

    return Parseable;

  })();

  mathJS.Poolable = (function() {
    function Poolable() {}

    Poolable._pool = [];

    Poolable.fromPool = function() {
      throw new Error("To be implemented");
    };

    Poolable["new"] = function() {
      if (arguments.length > 0) {
        return this.fromPool.apply(this, arguments);
      }
      return this.fromPool();
    };

    Poolable.prototype.release = function() {
      this.constructor._pool.push(this);
      return this.constructor;
    };

    return Poolable;

  })();


  /**
   * @abstract
   * @class Number
   * @constructor
   * @param {Number} value
   * @extends Object
  *
   */

  mathJS.Number = (function(_super) {
    __extends(Number, _super);

    Number._valueIsValid = function(value) {
      return value instanceof mathJS.Number || mathJS.isNum(value);
    };


    /**
    * This method gets the value from a parameter. The validity is determined by this._valueIsValid().
    * @static
    * @protected
    * @method _getValueFromParam
    * @param {Number} param
    * @param {Boolean} skipCheck
    * If `true` the given parameter is not (again) checked for validity. If the function that calls _getValueFromParam() has already checked the passed parameter this `skipCheck` should be set to true.
    * @return {Number} The primitive value or null.
    *
     */

    Number._getValueFromParam = function(param, skipCheck) {
      var value;
      if (!skipCheck && !this._valueIsValid(param)) {
        return null;
      }
      if (param instanceof mathJS.Number) {
        value = param.value;
      } else if (mathJS.isNum(param)) {
        value = param;
      }
      return value;
    };


    /**
    * @Override mathJS.Poolable
    * @static
    * @method fromPool
    *
     */

    Number.fromPool = function(val) {
      var number;
      if (this._pool.length > 0) {
        if (this._valueIsValid(val)) {
          number = this._pool.pop();
          number.value = val;
          return number;
        }
        return null;
      } else {
        return new this(val);
      }
    };


    /**
    * @Override mathJS.Parseable
    * @static
    * @method parse
    *
     */

    Number.parse = function(str) {
      var parsed;
      if (mathJS.isNum(parsed = parseFloat(str))) {
        return this.fromPool(parsed);
      }
      return parsed;
    };

    Number.random = function(max, min) {
      return this.fromPool(mathJS.randNum(max, min));
    };

    function Number(value) {
      var fStr;
      if (!this._valueIsValid(value)) {
        fStr = arguments.callee.caller.toString();
        throw new Error("mathJS: Expected plain number! Given " + value + " in '" + (fStr.substring(0, fStr.indexOf(")") + 1)) + "'");
      }
      Object.defineProperties(this, {
        value: {
          get: this._getValue,
          set: this._setValue
        },
        fromPool: {
          value: this.constructor.fromPool.bind(this.constructor),
          writable: false,
          enumarable: false,
          configurable: false
        }
      });
      this.value = this._getValueFromParam(value, true);
    }

    Number.prototype._setValue = function(value) {
      if (this._valueIsValid(value)) {
        this._value = this._getValueFromParam(value, true);
      }
      return this;
    };

    Number.prototype._getValue = function() {
      return this._value;
    };

    Number.prototype._valueIsValid = Number._valueIsValid;

    Number.prototype._getValueFromParam = Number._getValueFromParam;


    /**
    * @Override mathJS.Comparable
    * This method checks for mathmatical equality. This means new mathJS.Double(4.2).equals(4.2) is true.
    * @method equals
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Number.prototype.equals = function(n) {
      return this.value === this._getValueFromParam(n);
    };


    /**
    * @Override mathJS.Orderable
    * This method check for mathmatical '<'. This means new mathJS.Double(4.2).lessThan(5.2) is true.
    * @method lessThan
    *
     */

    Number.prototype.lessThan = function(n) {
      return this.value < this._getValueFromParam(n);
    };


    /**
    * @Override mathJS.Orderable
    * This method check for mathmatical '>'. This means new mathJS.Double(4.2).greaterThan(3.2) is true.
    * @method greaterThan
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Number.prototype.greaterThan = function(n) {
      return this.value > this._getValueFromParam(n);
    };


    /**
    * @Override mathJS.Orderable
    * This method check for mathmatical equality. This means new mathJS.Double(4.2).lessThanOrEqualTo(3.2) is true.
    * @method lessThanOrEqualTo
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Number.prototype.lessThanOrEqualTo = function(n) {
      return this.value <= this._getValueFromParam(n);
    };


    /**
    * This method check for mathmatical equality. This means new mathJS.Double(4.2).lessThanOrEqualTo(3.2) is true.
    * @method greaterThanOrEqualTo
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Number.prototype.greaterThanOrEqualTo = function(n) {
      return this.value >= this._getValueFromParam(n);
    };


    /**
    * This method adds 2 numbers and returns a new one.
    * @method plus
    * @param {Number} n
    * @return {Number} Calculated Number.
    *
     */

    Number.prototype.plus = function(n) {
      return this.fromPool(this.value + this._getValueFromParam(n));
    };


    /**
    * This method adds the given number to this instance.
    * @method increase
    * @param {Number} n
    * @return {Number} This instance.
    *
     */

    Number.prototype.increase = function(n) {
      this.value += this._getValueFromParam(n);
      return this;
    };


    /**
    * See increase().
    * @method plusSelf
    *
     */

    Number.prototype.plusSelf = Number.increase;


    /**
    * This method substracts 2 numbers and returns a new one.
    * @method minus
    * @param {Number} n
    * @return {Number} Calculated Number.
    *
     */

    Number.prototype.minus = function(n) {
      return this.fromPool(this.value - n);
    };

    Number.prototype.decrease = function(n) {
      this.value -= this._getValueFromParam(n);
      return this;
    };

    Number.prototype.minusSelf = Number.decrease;


    /**
    * This method multiplies 2 numbers and returns a new one.
    * @method times
    * @param {Number} n
    * @return {Number} Calculated Number.
    *
     */

    Number.prototype.times = function(n) {
      return this.fromPool(this.value * this._getValueFromParam(n));
    };

    Number.prototype.timesSelf = function(n) {
      this.value *= this._getValueFromParam(n);
      return this;
    };


    /**
    * This method divides 2 numbers and returns a new one.
    * @method divide
    * @param {Number} n
    * @return {Number} Calculated Number.
    *
     */

    Number.prototype.divide = function(n) {
      return this.fromPool(this.value / this._getValueFromParam(n));
    };

    Number.prototype.divideSelf = function(n) {
      this.value /= this._getValueFromParam(n);
      return this;
    };


    /**
    * This method squares this instance and returns a new one.
    * @method square
    * @return {Number} Calculated Number.
    *
     */

    Number.prototype.square = function() {
      return this.fromPool(this.value * this.value);
    };

    Number.prototype.squareSelf = function() {
      this.value *= this.value;
      return this;
    };


    /**
    * This method cubes this instance and returns a new one.
    * @method cube
    * @return {Number} Calculated Number.
    *
     */

    Number.prototype.cube = function() {
      return this.fromPool(this.value * this.value * this.value);
    };

    Number.prototype.cubeSelf = function() {
      this.value *= this.value * this.value;
      return this;
    };


    /**
    * This method calculates the square root of this instance and returns a new one.
    * @method sqrt
    * @return {Number} Calculated Number.
    *
     */

    Number.prototype.sqrt = function() {
      return this.fromPool(mathJS.sqrt(this.value));
    };

    Number.prototype.sqrtSelf = function() {
      this.value = mathJS.sqrt(this.value);
      return this;
    };


    /**
    * This method calculates the cubic root of this instance and returns a new one.
    * @method curt
    * @return {Number} Calculated Number.
    *
     */

    Number.prototype.curt = function() {
      return this.pow(1 / 3);
    };

    Number.prototype.curtSelf = function() {
      return this.powSelf(1 / 3);
    };


    /**
    * This method calculates any root of this instance and returns a new one.
    * @method plus
    * @param {Number} exponent
    * @return {Number} Calculated Number.
    *
     */

    Number.prototype.root = function(exp) {
      return this.pow(1 / exp);
    };

    Number.prototype.rootSelf = function(exp) {
      return this.powSelf(1 / exp);
    };


    /**
    * This method adds 2 numbers and returns a new one.
    * @method plus
    * @param {Number} n
    * @return {Number} Calculated Number.
    *
     */

    Number.prototype.reciprocal = function() {
      return this.fromPool(1 / this.value);
    };

    Number.prototype.reciprocalSelf = function() {
      this.value = 1 / this.value;
      return this;
    };


    /**
    * This method adds 2 numbers and returns a new one.
    * @method plus
    * @param {Number} n
    * @return {Number} Calculated Number.
    *
     */

    Number.prototype.pow = function(n) {
      return this.fromPool(mathJS.pow(this.value, this._getValueFromParam(n)));
    };

    Number.prototype.powSelf = function(n) {
      this.value = mathJS.pow(this.value, this._getValueFromParam(n));
      return this;
    };

    Number.prototype.sign = function() {
      return mathJS.sign(this.value);
    };

    Number.prototype.toInt = function() {
      return mathJS.Int.fromPool(mathJS.floor(this.value));
    };

    Number.prototype.toDouble = function() {
      return mathJS.Double.fromPool(this.value);
    };

    Number.prototype.toString = function() {
      return this.value.toString();
    };

    Number.prototype.clone = function() {
      return this.fromPool(this.value);
    };

    Number.prototype.release = function() {
      this.constructor._pool.push(this);
      return this.constructor;
    };

    return Number;

  })(mixOf(mathJS.Orderable, mathJS.Poolable, mathJS.Parseable));

  mathJS.Double = (function(_super) {
    __extends(Double, _super);

    function Double(value) {
      Double.__super__.constructor.apply(this, arguments);
    }

    return Double;

  })(mathJS.Number);

  mathJS.Fraction = (function(_super) {
    __extends(Fraction, _super);

    function Fraction(enumerator, denominator) {
      this.enumerator = enumerator;
      this.denominator = denominator;
      Object.defineProperty(this, "value", {
        get: function() {
          return this.enumerator / this.denominator;
        }
      });
    }

    return Fraction;

  })(mathJS.Number);


  /**
   * @class Int
   * @constructor
   * @param {Number} value
   * @extends Number
  *
   */

  mathJS.Int = (function(_super) {
    __extends(Int, _super);

    (function() {
      var inherited;
      inherited = Int._getValueFromParam.bind(Int);
      return Int._getValueFromParam = function(value) {
        return ~~inherited(value);
      };
    })();

    Int.parse = function(str) {
      var parsed;
      if (mathJS.isNum(parsed = parseIn(str, 10))) {
        return this.fromPool(parsed);
      }
      return parsed;
    };

    Int.random = function(max, min) {
      return this.fromPool(mathJS.randInt(max, min));
    };

    function Int(value) {
      Int.__super__.constructor.apply(this, arguments);
    }

    Int.prototype.isEven = function() {
      return __modulo(this.value, 2) === 0;
    };

    Int.prototype.isOdd = function() {
      return __modulo(this.value, 2) === 1;
    };

    Int.prototype.plus = function(n) {
      return this.constructor.fromPool(~~(this.value + this._getValueFromParam(n)));
    };

    Int.prototype.increase = function(n) {
      this.value += ~~this._getValueFromParam(n);
      return this;
    };

    Int.prototype.plusSelf = Int.increase;

    Int.prototype.minus = function(n) {
      return this.constructor.fromPool(~~(this.value - n));
    };

    Int.prototype.decrease = function(n) {
      this.value = ~~(this.value - this._getValueFromParam(n));
      return this;
    };

    Int.prototype.minusSelf = Int.decrease;

    Int.prototype.times = function(n) {
      return this.constructor.fromPool(~~(this.value * this._getValueFromParam(n)));
    };

    Int.prototype.timesSelf = function(n) {
      this.value = ~~(this.value * this._getValueFromParam(n));
      return this;
    };

    Int.prototype.divide = function(n) {
      return this.constructor.fromPool(~~(this.value / this._getValueFromParam(n)));
    };

    Int.prototype.divideSelf = function(n) {
      this.value = ~~(this.value / this._getValueFromParam(n));
      return this;
    };

    Int.prototype.sqrt = function() {
      return this.constructor.fromPool(~~(mathJS.sqrt(this.value)));
    };

    Int.prototype.sqrtSelf = function() {
      this.value = ~~mathJS.sqrt(this.value);
      return this;
    };

    Int.prototype.pow = function(n) {
      return this.constructor.fromPool(mathJS.pow(this.value, this._getValueFromParam(n)));
    };

    Int.prototype.powSelf = function(n) {
      this.value = mathJS.pow(this.value, this._getValueFromParam(n));
      return this;
    };

    Int.prototype.toInt = function() {
      return mathJS.Int.fromPool(this.value);
    };

    return Int;

  })(mathJS.Number);


  /**
   * @abstract
   * @class Complex
   * @constructor
   * @param {Number} real
   * Real part of the number. Either a mathJS.Number or primitive number.
   * @param {Number} image
   * Real part of the number. Either a mathJS.Number or primitive number.
   * @extends Number
  *
   */

  mathJS.Complex = (function(_super) {
    var PARSE_KEY;

    __extends(Complex, _super);

    PARSE_KEY = "0c";


    /**
    * @Override
    * This method creates an object with the keys 'real' and 'img' which have primitive numbers as their values.
    * @static
    * @method _getValueFromParam
    * @param {Complex|Number} real
    * @param {Number} img
    * @return {Object}
    *
     */

    Complex._getValueFromParam = function(real, img) {
      if (real instanceof mathJS.Complex) {
        return {
          real: real.real,
          img: real.img
        };
      }
      if (real instanceof mathJS.Number && img instanceof mathJS.Number) {
        return {
          real: real.value,
          img: img.value
        };
      }
      if (mathJS.isNum(real) && mathJS.isNum(img)) {
        return {
          real: real,
          img: img
        };
      }
      return null;
    };

    Complex.fromPool = function(real, img) {
      var number;
      if (this._pool.length > 0) {
        if (this._valueIsValid(real) && this._valueIsValid(img)) {
          number = this._pool.pop();
          number.real = real;
          number.img = img;
          return number;
        }
        return null;
      } else {
        return new this(real, img);
      }
    };

    Complex.parse = function(str) {
      var idx, img, parts, real;
      idx = str.toLowerCase().indexOf(PARSE_KEY);
      if (idx >= 0) {
        parts = str.substring(idx + PARSE_KEY.length).split(",");
        if (mathJS.isNum(real = parseFloat(parts[0])) && mathJS.isNum(img = parseFloat(parts[1]))) {
          return this.fromPool(real, img);
        }
      }
      return NaN;
    };

    Complex.random = function(max1, min1, max2, min2) {
      return this.fromPool(mathJS.randNum(max1, min1), mathJS.randNum(max2, min2));
    };

    function Complex(real, img) {
      var fStr, values;
      values = this._getValueFromParam(real, img);
      if (values == null) {
        fStr = arguments.callee.caller.toString();
        throw new Error("mathJS: Expected 2 numbers or a complex number! Given (" + real + ", " + img + ") in '" + (fStr.substring(0, fStr.indexOf(")") + 1)) + "'");
      }
      Object.defineProperties(this, {
        real: {
          get: this._getReal,
          set: this._setReal
        },
        img: {
          get: this._getImg,
          set: this._setImg
        },
        fromPool: {
          value: this.constructor.fromPool.bind(this.constructor),
          writable: false,
          enumarable: false,
          configurable: false
        }
      });
      this.real = values.real;
      this.img = values.img;
    }

    Complex.prototype._setReal = function(value) {
      if (this._valueIsValid(value)) {
        this._real = value.value || value.real || value;
      }
      return this;
    };

    Complex.prototype._getReal = function() {
      return this._real;
    };

    Complex.prototype._setImg = function(value) {
      if (this._valueIsValid(value)) {
        this._img = value.value || value.img || value;
      }
      return this;
    };

    Complex.prototype._getImg = function() {
      return this._img;
    };

    Complex.prototype._getValueFromParam = Complex._getValueFromParam;


    /**
    * This method check for mathmatical equality. This means new mathJS.Double(4.2).equals(4.2)
    * @method equals
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Complex.prototype.equals = function(r, i) {
      var values;
      values = this._getValueFromParam(r, i);
      if (values != null) {
        return this.real === values.real && this.img === values.img;
      }
      return false;
    };

    Complex.prototype.plus = function(r, i) {
      var values;
      values = this._getValueFromParam(r, i);
      if (values != null) {
        return this.fromPool(this.real + values.real, this.img + values.img);
      }
      return NaN;
    };

    Complex.prototype.increase = function(r, i) {
      var values;
      values = this._getValueFromParam(r, i);
      if (values != null) {
        this.real += values.real;
        this.img += values.img;
      }
      return this;
    };

    Complex.prototype.plusSelf = Complex.increase;

    Complex.prototype.minus = function(n) {
      var values;
      values = this._getValueFromParam(r, i);
      if (values != null) {
        return this.fromPool(this.real - values.real, this.img - values.img);
      }
      return NaN;
    };

    Complex.prototype.decrease = function(n) {
      var values;
      values = this._getValueFromParam(r, i);
      if (values != null) {
        this.real -= values.real;
        this.img -= values.img;
      }
      return this;
    };

    Complex.prototype.minusSelf = Complex.decrease;

    Complex.prototype.times = function(r, i) {
      var values;
      values = this._getValueFromParam(r, i);
      if (values != null) {
        return this.fromPool(this.real * values.real, this.img * values.img);
      }
      return NaN;
    };

    Complex.prototype.timesSelf = function(n) {
      this.value *= _getValueFromParam(n);
      return this;
    };

    Complex.prototype.divide = function(n) {
      return this.fromPool(this.value / _getValueFromParam(n));
    };

    Complex.prototype.divideSelf = function(n) {
      this.value /= _getValueFromParam(n);
      return this;
    };

    Complex.prototype.square = function() {
      return this.fromPool(this.value * this.value);
    };

    Complex.prototype.squareSelf = function() {
      this.value *= this.value;
      return this;
    };

    Complex.prototype.cube = function() {
      return this.fromPool(this.value * this.value * this.value);
    };

    Complex.prototype.squareSelf = function() {
      this.value *= this.value * this.value;
      return this;
    };

    Complex.prototype.sqrt = function() {
      return this.fromPool(mathJS.sqrt(this.value));
    };

    Complex.prototype.sqrtSelf = function() {
      this.value = mathJS.sqrt(this.value);
      return this;
    };

    Complex.prototype.pow = function(n) {
      return this.fromPool(mathJS.pow(this.value, _getValueFromParam(n)));
    };

    Complex.prototype.powSelf = function(n) {
      this.value = mathJS.pow(this.value, _getValueFromParam(n));
      return this;
    };

    Complex.prototype.sign = function() {
      return mathJS.sign(this.value);
    };

    Complex.prototype.toInt = function() {
      return mathJS.Int.fromPool(mathJS.floor(this.value));
    };

    Complex.prototype.toDouble = function() {
      return mathJS.Double.fromPool(this.value);
    };

    Complex.prototype.toString = function() {
      return "" + PARSE_KEY + (this.real.toString()) + "," + (this.img.toString());
    };

    Complex.prototype.clone = function() {
      return this.fromPool(this.value);
    };

    Complex.prototype.release = function() {
      this.constructor._pool.push(this);
      return this.constructor;
    };

    return Complex;

  })(mathJS.Number);


  /**
  * @class Variable
  * @constructor
  * @param {String} symbol
  * This is name name of the variable (mathematically)
  * @param {Function|Class} type
  * @param {Object} value
  * Optional. This param is passed upon evaluation.
  *
   */

  mathJS.Variable = (function() {
    function Variable(symbol, type, value) {
      this.symbol = symbol;
      this.type = type;
      this.value = value;
    }

    Variable.prototype.plus = function(x) {
      var _base;
      return (typeof (_base = this.value).plus === "function" ? _base.plus(x) : void 0) || null;
    };

    Variable.prototype.minus = function(x) {
      var _base;
      return (typeof (_base = this.value).minus === "function" ? _base.minus(x) : void 0) || null;
    };

    Variable.prototype.times = function(x) {
      var _base;
      return (typeof (_base = this.value).times === "function" ? _base.times(x) : void 0) || null;
    };

    Variable.prototype.divide = function(x) {
      var _base;
      return (typeof (_base = this.value).divide === "function" ? _base.divide(x) : void 0) || null;
    };

    return Variable;

  })();

  mathJS.Operation = (function() {
    function Operation(name, precedence, associativity, func, inverse) {
      if (associativity == null) {
        associativity = "left";
      }
      this.name = name;
      this.precedence = precedence;
      this.associativity = associativity;
      this.func = func;
      this.params = func.length;
      this.inverse = inverse || null;
    }

    Operation.prototype.invert = function() {
      if (this.inverse != null) {
        return this.inverse.apply(this, arguments);
      }
      return null;
    };

    return Operation;

  })();

  mathJS.ops = {
    pow: new mathJS.Operation("pow", 1, "right", mathJS.pow, mathJS.root)
  };


  /**
  * Tree structure of terms
  * @class Term
  
  *
   */

  mathJS.Term = (function() {
    Term.prototype.fromString = function(str) {
      return new mathJS.Term();
    };

    function Term() {
      var arg, i, l, operations, terms, _i, _j, _len;
      l = arguments.length;
      if (l >= 3 && l % 2 === 1) {
        terms = [];
        for (_i = 0, _len = arguments.length; _i < _len; _i += 2) {
          arg = arguments[_i];
          terms.push(arg);
        }
        this.terms = terms;
        operations = [];
        for (i = _j = 1; 1 <= l ? _j < l : _j > l; i = 1 <= l ? ++_j : --_j) {
          if (i % 2 === 1) {
            operations.push(arguments[i]);
          }
        }
        this.operations = operations;
      } else if (l === 1) {
        this.terms = [arguments[0]];
      }
    }

    Term.prototype["eval"] = function(values) {
      var op, ops, precedence, res, term, term1, term2, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _results;
      ops = this.operations.clone();
      for (precedence = _i = 1; _i < 20; precedence = ++_i) {
        _ref = this.operations;
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          op = _ref[_j];
          if (op.precedence === precedence) {
            term1 = this.operations[idx];
            term2 = this.operations[idx + 1];
          }
        }
      }
      for (_k = 0, _len1 = ops.length; _k < _len1; _k++) {
        op = ops[_k];
        precedence = op.precedence;
      }
      ops.sortProp(function(op) {
        return op.precedence;
      });
      console.log(ops);
      res = null;
      _ref1 = this.terms;
      _results = [];
      for (_l = 0, _len2 = _ref1.length; _l < _len2; _l++) {
        term = _ref1[_l];
        _results.push(true);
      }
      return _results;
    };

    return Term;

  })();

  mathJS.Equation = (function() {
    function Equation(term1, term2) {
      this.term1 = term1;
      this.term2 = term2;
    }

    return Equation;

  })();

  mathJS.SetSpec = (function() {
    function SetSpec(isFinite, f, f2) {
      if (isFinite === true || isFinite === "true") {
        this.isFinite = true;
        this.checker = f;
        this.generator = f2;
      } else if (isFinite === false || isFinite === "false") {
        this.checker = f;
        if (isFinite === true) {
          this.generator = generator;
        }
      } else {
        debugger;
        throw new Error("mathJS: Expected (Function, boolean) for SetSpec! Given " + check + " and " + isFinite);
      }
    }

    return SetSpec;

  })();

  mathJS.SetBuilder = (function() {
    function SetBuilder() {
      var conditions, domain, expression;
      expression = arguments[0], domain = arguments[1], conditions = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    }

    return SetBuilder;

  })();


  /*
  {7,3,15,31}
  {a,b,c}
  {1,2,3,...,100}
  {0,1,2,...}
  
  {x : x in R and x = x^2 } or {x | x in R and x = x^2 }
  { (x,y) | 0 < y < f(x) }
  { (t,2t+1) | t in Z }
  
  [a,b] = { x | x in R and a <= x <= b }
  
  equal predicates <=> equal sets (if expressions (in front) also equal)!!!
  { x | x in R and |x| = 1 } <=> { x | x in R and x^2 = 1 }
  
  
  dicht oder nicht?
  nicht dicht + bounded => diskret
  N -> left boundary
  mathJS.Root class for difference Q <-> R
   */


  /**
  * @class Set
  * @constructor
  * @param {Object} boundarySettings
  * @param {Function} condition
  * Optional. If given, the created Set will bounded by that condition
  * @param {Array} elems
  * Optional. This parameter serves as elements for the new Set. They will be in the new Set immediately.
  * It is an array of comparable elements (that means if `mathJS.isComparable() === true`); non-comparables will be ignored.
  *
   */

  mathJS.Set = (function(_super) {
    __extends(Set, _super);

    Set._isSet = function(set) {
      return set instanceof mathJS.Set || set["instanceof"](mathJS.Set);
    };

    function Set(boundarySettings, condition, elems) {
      var elem, _i, _len;
      if (elems == null) {
        elems = [];
      }
      if (arguments.length === 0) {
        return;
      }
      if (boundarySettings == null) {
        boundarySettings = {
          leftBoundary: null,
          rightBoundary: null
        };
      }
      this.leftBoundary = boundarySettings.leftBoundary;
      this.rightBoundary = boundarySettings.rightBoundary;
      if (condition instanceof Function) {
        this.condition = condition;
      } else {
        this.condition = null;
      }
      this._discreteSet = new mathJS.DiscreteSet();
      this._conditionalSet = new mathJS.ConditionalSet();
      for (_i = 0, _len = elems.length; _i < _len; _i++) {
        elem = elems[_i];
        if (mathJS.isComparable(elem)) {
          if (elem instanceof mathJS.DiscreteSet || (typeof elem["instanceof"] === "function" ? elem["instanceof"](mathJS.DiscreteSet) : void 0)) {
            this._discreteSet = this._discreteSet.union(elem);
          } else if (elem instanceof mathJS.ConditionalSet || (typeof elem["instanceof"] === "function" ? elem["instanceof"](mathJS.ConditionalSet) : void 0)) {
            this._conditionalSet = this._conditionalSet.union(elem);
          } else {
            this._discreteSet = this._discreteSet.union(new mathJS.DiscreteSet([elem]));
          }
        }
      }
      Object.defineProperties(this, {
        _universe: {
          value: null,
          enumerable: false,
          writable: true
        },
        universe: {
          get: function() {
            return this._universe;
          },
          set: function(universe) {
            if (universe instanceof mathJS.Set || universe === null) {
              this._universe = universe;
            }
            return this;
          },
          enumerable: true
        },
        size: {
          value: this._discreteSet.size + this._conditionalSet.size,
          enumerable: true,
          writable: false,
          configurable: true
        }
      });
    }

    Set.prototype.clone = function() {
      throw new Error("todo!");
    };

    Set.prototype.equals = function(set) {
      throw new Error("todo!");
    };

    Set.prototype.isSubsetOf = function(set) {
      throw new Error("todo!");
    };

    Set.prototype.isSupersetOf = function(set) {
      throw new Error("todo!");
    };

    Set.prototype.forAll = function() {};

    Set.prototype.exists = function() {};

    Set.prototype.contains = function(elem) {
      var subset, _i, _len, _ref;
      if (elem instanceof this.type) {
        _ref = this.subsets;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          subset = _ref[_i];
          if (subset.contains(elem)) {
            return true;
          }
        }
      }
      return false;
    };

    Set.prototype.has = Set.prototype.contains;

    Set.prototype.union = function(set) {
      return this;
    };

    Set.prototype.intersect = function(set) {};

    Set.prototype.intersects = function(set) {
      return this.intersection.size() > 0;
    };

    Set.prototype.disjoint = function(set) {
      return this.intersection.size() === 0;
    };

    Set.prototype.complement = function() {
      if (this.universe != null) {
        return asdf;
      }
      return new mathJS.EmptySet();
    };


    /**
    * a.without b => returns: removed all common elements from a
    *
     */

    Set.prototype.without = function(set) {};

    Set.prototype.cartesianProduct = function(set) {};

    Set.prototype.times = Set.prototype.cartesianProduct;

    Set.prototype.isEmpty = function() {
      return this.size === 0;
    };

    return Set;

  })(mixOf(mathJS.Poolable, mathJS.Comparable, mathJS.Parseable));


  /**
  * This class is a Setof explicitely listed elements (with no needed logic).
  * @class DiscreteSet
  * @constructor
  * @param {Function|Class} type
  * @param {Set} universe
  * Optional. If given, the created Set will be interpreted as a sub set of the universe.
  * @param {mixed} elems...
  * Optional. This and the following parameters serve as elements for the new Set. They will be in the new Set immediately.
  * @extends Set
  *
   */

  mathJS.DiscreteSet = (function(_super) {
    __extends(DiscreteSet, _super);

    function DiscreteSet(elems) {
      var elem, _i, _len;
      if (elems == null) {
        elems = [];
      }
      this.leftBoundary = null;
      this.rightBoundary = null;
      this.condition = null;
      this.elems = [];
      for (_i = 0, _len = elems.length; _i < _len; _i++) {
        elem = elems[_i];
        if (mathJS.isComparable(elem) && !this.contains(elem)) {
          this.elems.push(elem);
        }
      }
      Object.defineProperties(this, {
        elems: {
          value: this.elems,
          enumerable: false
        },
        _universe: {
          value: null,
          enumerable: false,
          writable: true
        },
        universe: {
          get: function() {
            return this._universe;
          },
          set: function(universe) {
            if (universe instanceof mathJS.Set || universe === null) {
              this._universe = universe;
            }
            return this;
          },
          enumerable: true
        },
        size: {
          value: this.elems.length,
          enumerable: false,
          writable: false,
          configurable: true
        }
      });
    }

    DiscreteSet.prototype.isSubsetOf = function(set) {
      var e, _i, _len, _ref;
      _ref = this.elems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        if (!set.contains(e)) {
          return false;
        }
      }
      return true;
    };

    DiscreteSet.prototype.isSupersetOf = function(set) {
      return set.isSubsetOf(this);
    };

    DiscreteSet.prototype.clone = function() {
      return new mathJS.DiscreteSet(this.elems);
    };


    /**
    * @Override
    *
     */

    DiscreteSet.prototype.equals = function(set) {
      return this.isSubsetOf(set) && set.isSubsetOf(this);
    };

    DiscreteSet.prototype.contains = function(elem) {
      var e, _i, _len, _ref;
      if (mathJS.isComparable(elem)) {
        _ref = this.elems;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          e = _ref[_i];
          if (e === elem || (typeof e.equals === "function" ? e.equals(elem) : void 0)) {
            return true;
          }
        }
      }
      return false;
    };

    DiscreteSet.prototype.union = function(set) {
      if (set instanceof mathJS.DiscreteSet) {
        return new mathJS.DiscreteSet(this.elems.concat(set.elems));
      } else if (set instanceof mathJS.ConditionalSet) {
        return "asdf";
      }
    };

    DiscreteSet.prototype.intersect = function(set) {
      var elems, res, x, y, _i, _j, _len, _len1, _ref, _ref1;
      if (set instanceof mathJS.DiscreteSet) {
        elems = [];
        _ref = this.elems;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          _ref1 = set.elems;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            y = _ref1[_j];
            if (x.equals(y)) {
              elems.push(x);
            }
          }
        }
        if (elems.length > 0) {
          res = new mathJS.DiscreteSet(this.type, this.universe);
        }
      } else if (set instanceof mathJS.ConditionalSet) {

      } else if (set instanceof mathJS.EmptySet) {
        return new mathJS.EmptySet();
      }
      return null;
    };

    DiscreteSet.prototype.complement = function() {
      if (this.universe != null) {
        return;
      }
      return new mathJS.EmptySet();
    };


    /**
    * a.without b => returns: removed all common elements from a
    *
     */

    DiscreteSet.prototype.without = function(set) {};

    return DiscreteSet;

  })(mathJS.Set);

  mathJS.ConditionalSet = (function(_super) {
    __extends(ConditionalSet, _super);

    function ConditionalSet(condition, universe) {
      if (universe == null) {
        universe = null;
      }
      if (condition instanceof mathJS.SetSpec) {
        this.condition = condition;
      } else {
        this.condition = null;
      }
      this.leftBoundary = null;
      this.rightBoundary = null;
      Object.defineProperties(this, {
        _universe: {
          value: universe,
          enumerable: false,
          writable: true
        },
        universe: {
          get: function() {
            return this._universe;
          },
          set: function(universe) {
            if (universe instanceof mathJS.Set || universe === null) {
              this._universe = universe;
            }
            return this;
          },
          enumerable: true
        },
        size: {
          value: this.elems.length,
          enumerable: false,
          writable: false,
          configurable: true
        }
      });
    }

    ConditionalSet.prototype.clone = function() {
      throw new Error("todo!");
    };

    ConditionalSet.prototype.equals = function(set) {
      throw new Error("todo!");
    };

    ConditionalSet.prototype.isSubsetOf = function(set) {
      throw new Error("todo!");
    };

    ConditionalSet.prototype.isSupersetOf = function(set) {
      throw new Error("todo!");
    };

    ConditionalSet.prototype.forAll = function() {};

    ConditionalSet.prototype.exists = function() {};

    ConditionalSet.prototype.contains = function(elem) {
      var _ref;
      if (mathJS.isComparable(elem)) {
        if (((_ref = this.condition) != null ? _ref.check(elem) : void 0) === true) {
          return true;
        }
      }
      return false;
    };

    ConditionalSet.prototype.union = function(set) {
      return this;
    };

    ConditionalSet.prototype.intersect = function(set) {};

    ConditionalSet.prototype.intersects = function(set) {
      return this.intersection.size() > 0;
    };

    ConditionalSet.prototype.disjoint = function(set) {
      return this.intersection.size() === 0;
    };

    ConditionalSet.prototype.complement = function() {
      if (this.universe != null) {
        return asdf;
      }
      return new mathJS.EmptySet();
    };


    /**
    * a.without b => returns: removed all common elements from a
    *
     */

    ConditionalSet.prototype.without = function(set) {};

    ConditionalSet.prototype.cartesianProduct = function(set) {};

    ConditionalSet.prototype.times = ConditionalSet.prototype.cartesianProduct;

    ConditionalSet.prototype.isEmpty = function() {
      return this.size > 0;
    };

    ConditionalSet.prototype.cardinality = ConditionalSet.prototype.size;

    return ConditionalSet;

  })(mathJS.Set);

  mathJS.Domains.N = (function(_super) {
    var CLASS;

    __extends(N, _super);

    CLASS = N;

    function N() {
      Object.defineProperties(this, {
        generator: {
          value: function(n) {
            return n;
          },
          writable: false,
          enumerable: false,
          configurable: false
        },
        expression: {
          value: function(x) {
            return x;
          },
          writable: false,
          enumerable: false,
          configurable: false
        },
        isCountable: {
          value: true,
          enumerable: true,
          writable: false,
          configurable: false
        },
        size: {
          value: Infinity,
          enumerable: true,
          writable: false,
          configurable: false
        },
        isMutable: {
          value: false,
          writable: false,
          enumerable: false,
          configurable: false
        },
        leftBoundary: {
          value: {
            value: -Infinity,
            open: true
          },
          writable: false,
          enumerable: false,
          configurable: false
        },
        rightBoundary: {
          value: {
            value: +Infinity,
            open: true
          },
          writable: false,
          enumerable: false,
          configurable: false
        }
      });
    }

    N.contains = function(x) {
      return mathJS.isInt(x) || new mathJS.Int(x).equals(x);
    };

    N.prototype.contains = CLASS.contains;

    N.prototype.clone = function() {
      return new mathJS.Domains.N();
    };

    N.prototype.equals = function(set, n) {
      var generator, i, val;
      if (n == null) {
        n = mathJS.settings.set.maxIterations * 10;
      }
      if (this._isSet(set)) {
        if (set.size === Infinity) {
          generator = this.generator;
          i = 0;
          while (i++ < n) {
            val = generator(i);
            if (!set.contains(val)) {
              return false;
            }
            if (DEBUG) {
              console.log("japp");
            }
          }
          return true;
        }
        return false;
      }
      return false;
    };


    /**
    * This method checks if `this` is a subset of the given set `set`. Since equality must be checked by checking an arbitrary number of values this method actually does the same as `this.equals()`. For `this.equals()` the number of compared elements is 10x bigger.
    *
     */

    N.prototype.isSubsetOf = function(set, n) {
      if (n == null) {
        n = mathJS.settings.set.maxIterations;
      }
      return this.equals(set, n * 10);
    };

    N.prototype.isSupersetOf = function(set) {
      if (this._isSet(set)) {
        return set.isSubsetOf(this);
      }
      return false;
    };

    N.prototype.union = function(set, n, matches) {
      var checker, self;
      if (n == null) {
        n = mathJS.settings.set.maxIterations;
      }
      if (matches == null) {
        matches = mathJS.settings.set.maxMatches;
      }
      checker = function(elem) {
        return self.checker(elem) || set.checker(elem);
      };
      if (set instanceof mathJS.DiscreteSet || (typeof set["instanceof"] === "function" ? set["instanceof"](mathJS.DiscreteSet) : void 0)) {

      } else if (set instanceof mathJS.Set || (typeof set["instanceof"] === "function" ? set["instanceof"](mathJS.Set) : void 0)) {
        if (mathJS["instanceof"](set, mathJS.Domains.N)) {
          return this;
        }
        if (mathJS["instanceof"](set, mathJS.Domains.Q) || mathJS["instanceof"](set, mathJS.Domains.R)) {
          return set;
        }
        self = this;
      }
      return null;
    };

    N.prototype.intersect = function(set) {
      var checker, commonElements, elem, f1, f1Elem, f1Elems, f2, f2Elem, f2Elems, found, i, m, ops, x, y1, y2, _i, _j, _k, _len, _len1, _len2;
      checker = function(elem) {
        return self.checker(elem) && set.checker(elem);
      };
      commonElements = [];
      x = 0;
      m = 0;
      f1 = this.generator;
      f2 = set.generator;
      f1Elems = [];
      f2Elems = [];
      while (x < n && m < matches) {
        y1 = f1(x);
        y2 = f2(x);
        if (mathJS.gt(y1, y2)) {
          found = false;
          for (i = _i = 0, _len = f1Elems.length; _i < _len; i = ++_i) {
            f1Elem = f1Elems[i];
            if (!(mathJS.equals(y2, f1Elem))) {
              continue;
            }
            m++;
            found = true;
            commonElements.push(y2);
            f1Elems = f1Elems.slice(i + 1);
            f2Elems = [];
            break;
          }
          if (!found) {
            f1Elems.push(y1);
            f2Elems.push(y2);
          }
        } else if (mathJS.lt(y1, y2)) {
          found = false;
          for (i = _j = 0, _len1 = f2Elems.length; _j < _len1; i = ++_j) {
            f2Elem = f2Elems[i];
            if (!(mathJS.equals(y1, f2Elem))) {
              continue;
            }
            m++;
            found = true;
            commonElements.push(y1);
            f2Elems = f2Elems.slice(i + 1);
            f1Elems = [];
            break;
          }
          if (!found) {
            f1Elems.push(y1);
            f2Elems.push(y2);
          }
        } else {
          m++;
          commonElements.push(y1);
          f1Elems = [];
          f2Elems = [];
        }
        x++;
      }
      console.log("x=" + x, "m=" + m, commonElements);
      ops = [];
      for (_k = 0, _len2 = commonElements.length; _k < _len2; _k++) {
        elem = commonElements[_k];
        true;
      }
    };

    N.prototype.intersects = function(set) {
      return this.intersection(set).size > 0;
    };

    N.prototype.disjoint = function(set) {
      return this.intersection(set).size === 0;
    };

    N.prototype.complement = function() {
      if (this.universe != null) {
        return this.universe.without(this);
      }
      return new mathJS.EmptySet();
    };


    /**
    * a.without b => returns: removed all common elements from a
    *
     */

    N.prototype.without = function(set) {};

    N.prototype.cartesianProduct = function(set) {};

    N.prototype.times = N.prototype.cartesianProduct;

    return N;

  })(mathJS.Set);

  (function() {
    var clss;
    clss = mathJS.Domains.N;
    mathJS.Domains.N = new mathJS.Domains.N();
    return mathJS.Domains.N["new"] = function() {
      return new clss();
    };
  })();

  mathJS.Function = (function(_super) {
    __extends(Function, _super);

    function Function(fromSet, toSet, mapping) {
      this.fromSet = fromSet;
      this.toSet = toSet;
      this.mapping = mapping;
    }

    return Function;

  })(mathJS.ConditionalSet);

  mathJS.Vector = (function() {
    Vector.prototype._isVectorLike = function(v) {
      return v instanceof mathJS.Vector || (typeof v["instanceof"] === "function" ? v["instanceof"](mathJS.Vector) : void 0) || v instanceof mathJS.Tuple || (typeof v["instanceof"] === "function" ? v["instanceof"](mathJS.Tuple) : void 0);
    };

    Vector._isVectorLike = Vector.prototype._isVectorLike;

    function Vector(values) {
      var val, _i, _len;
      this.values = values;
      if (DEBUG) {
        for (_i = 0, _len = values.length; _i < _len; _i++) {
          val = values[_i];
          if (!mathJS.isMathJSNum(val)) {
            console.warn("invalid value:", val);
          }
        }
      }
    }

    Vector.prototype.equals = function(v) {
      var i, vValue, val, _i, _len, _ref;
      if (!this._isVectorLike(v)) {
        return false;
      }
      _ref = this.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        val = _ref[i];
        vValue = v.values[i];
        if (!(typeof val.equals === "function" ? val.equals(vValue) : void 0) && val !== vValue) {
          return false;
        }
      }
      return true;
    };

    Vector.prototype.clone = function() {
      return new TD.Vector(this.values);
    };

    Vector.prototype.move = function(v) {
      var i, vValue, val, _i, _len, _ref;
      if (!this._isVectorLike(v)) {
        return this;
      }
      _ref = v.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        val = _ref[i];
        vValue = v.values[i];
        this.values[i] = (typeof vValue.plus === "function" ? vValue.plus(val) : void 0) || (typeof val.plus === "function" ? val.plus(vValue) : void 0) || (vValue + val);
      }
      return this;
    };

    Vector.prototype.moveBy = Vector.move;

    Vector.prototype.moveTo = function(p) {
      var i, vValue, val, _i, _len, _ref;
      if (!this._isVectorLike(v)) {
        return this;
      }
      _ref = v.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        val = _ref[i];
        vValue = v.values[i];
        this.values[i] = vValue.value || vValue;
      }
      return this;
    };

    Vector.prototype.multiply = function(r) {
      if (Math.isNum(r)) {
        return new TD.Point(this.x * r, this.y * r);
      }
      return null;
    };

    Vector.prototype.times = Vector.multiply;

    Vector.prototype.magnitude = function() {
      var i, sum, val, _i, _len, _ref;
      sum = 0;
      _ref = this.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        val = _ref[i];
        sum += val * val;
      }
      return Math.sqrt(sum);
    };


    /**
     * This method calculates the distance between 2 points.
     * It's a shortcut for substracting 2 vectors and getting that vector's magnitude (because no new object is created).
     * For that reason this method should be used for pure distance calculations.
     *
     * @method distanceTo
     * @param {Point} p
     * @return {Number} Distance between this point and p.
    *
     */

    Vector.prototype.distanceTo = function(v) {
      var i, sum, val, _i, _len, _ref;
      sum = 0;
      _ref = this.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        val = _ref[i];
        sum += (val - v.values[i]) * (val - v.values[i]);
      }
      return Math.sqrt(sum);
    };

    Vector.prototype.add = function(v) {
      var i, vValue, val, values, _i, _len, _ref;
      if (!this._isVectorLike(v)) {
        return null;
      }
      values = [];
      _ref = v.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        val = _ref[i];
        vValue = v.values[i];
        values.push((typeof vValue.plus === "function" ? vValue.plus(val) : void 0) || (typeof val.plus === "function" ? val.plus(vValue) : void 0) || (vValue + val));
      }
      return new mathJS.Vector(values);
    };

    Vector.prototype.plus = Vector.add;

    Vector.prototype.substract = function(p) {
      if (isPointLike(p)) {
        return new TD.Point(this.x - p.x, this.y - p.y);
      }
      return null;
    };

    Vector.prototype.minus = Vector.substract;

    Vector.prototype.xyRatio = function() {
      return this.x / this.y;
    };

    Vector.prototype.toArray = function() {
      return [this.x, this.y];
    };

    Vector.prototype.isPositive = function() {
      return this.x >= 0 && this.y >= 0;
    };


    /**
     * Returns the angle of a vector. Beware that the angle is measured in counter clockwise direction beginning at 0˚ which equals the x axis in positive direction.
     * So on a computer grid the angle won't be what you expect! Use anglePC() in that case!
     *
     * @method angle
     * @return {Number} Angle of the vector in degrees. 0 degrees means pointing to the right.
    *
     */

    Vector.prototype.angle = function() {
      if (this.x >= 0 && this.y >= 0) {
        return Math.radToDeg(Math.atan(Math.abs(this.y) / Math.abs(this.x))) % 360;
      }
      if (this.x < 0 && this.y > 0) {
        return (90 + Math.radToDeg(Math.atan(Math.abs(this.x) / Math.abs(this.y)))) % 360;
      }
      if (this.x < 0 && this.y < 0) {
        return (180 + Math.radToDeg(Math.atan(Math.abs(this.y) / Math.abs(this.x)))) % 360;
      }
      return (270 + Math.radToDeg(Math.atan(Math.abs(this.x) / Math.abs(this.y)))) % 360;
    };


    /**
     * Returns the angle of a vector. 0˚ means pointing to the top. Clockwise.
     *
     * @method anglePC
     * @return {Number} Angle of the vector in degrees. 0 degrees means pointing to the right.
    *
     */

    Vector.prototype.anglePC = function() {
      if (this.x >= 0 && this.y >= 0) {
        return (90 + Math.radToDeg(Math.atan(Math.abs(this.y) / Math.abs(this.x)))) % 360;
      }
      if (this.x < 0 && this.y > 0) {
        return (180 + Math.radToDeg(Math.atan(Math.abs(this.x) / Math.abs(this.y)))) % 360;
      }
      if (this.x < 0 && this.y < 0) {
        return (270 + Math.radToDeg(Math.atan(Math.abs(this.y) / Math.abs(this.x)))) % 360;
      }
      return Math.radToDeg(Math.atan(Math.abs(this.x) / Math.abs(this.y))) % 360;
    };


    /**
     * Returns a random Point within a given radius.
     *
     * @method randPointInRadius
     * @param {Number} radius
     * Default is 10 (pixels). Must not be smaller than 0.
     * @param {Boolean} random
     * Indicates whether the given radius is the maximum or exact distance between the 2 points.
     * @return {Number} Random Point.
    *
     */

    Vector.prototype.randPointInRadius = function(radius, random) {
      var angle, x, y;
      if (radius == null) {
        radius = 5;
      }
      if (random == null) {
        random = false;
      }
      angle = Math.degToRad(Math.randNum(0, 360));
      if (random === true) {
        radius = Math.randNum(0, radius);
      }
      x = radius * Math.cos(angle);
      y = radius * Math.sin(angle);
      return this.add(new TD.Point(x, y));
    };

    return Vector;

  })();

  mathJS.Tuple = (function(_super) {
    __extends(Tuple, _super);

    function Tuple() {
      return Tuple.__super__.constructor.apply(this, arguments);
    }

    return Tuple;

  })(mathJS.Vector);

  $(document).ready(function() {
    return console.log("dom ready");
  });

}).call(this);
