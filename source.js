// Generated by CoffeeScript 1.9.3

/**
 * @module mathJS
 * @main mathJS
*
 */

(function() {
  var _mathJS, cached, diff, startTime,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; child.__superClass__ = parent; return child; },
    hasProp = {}.hasOwnProperty;

  if (typeof DEBUG === "undefined") {
    window.DEBUG = true;
  }

  window.mathJS = {
    Algorithms: {},
    Domains: {},
    Errors: {},
    Geometry: {},
    Operations: {},
    Sets: {},
    Utils: {}
  };

  _mathJS = $.extend({}, mathJS);

  if (DEBUG) {
    window._mathJS = _mathJS;
    startTime = Date.now();
  }

  Array.prototype.reverseCopy = function() {
    var item, l, res;
    res = [];
    for (l = this.length - 1; l >= 0; l += -1) {
      item = this[l];
      res.push(item);
    }
    return res;
  };

  Array.prototype.unique = function() {
    var elem, l, len1, res;
    res = [];
    for (l = 0, len1 = this.length; l < len1; l++) {
      elem = this[l];
      if (indexOf.call(res, elem) < 0) {
        res.push(elem);
      }
    }
    return res;
  };

  Array.prototype.sample = function(n, forceArray) {
    var arr, elem, i, res;
    if (n == null) {
      n = 1;
    }
    if (forceArray == null) {
      forceArray = false;
    }
    if (n === 1) {
      if (!forceArray) {
        return this[Math.floor(Math.random() * this.length)];
      }
      return [this[Math.floor(Math.random() * this.length)]];
    }
    if (n > this.length) {
      n = this.length;
    }
    i = 0;
    res = [];
    arr = this.clone();
    while (i++ < n) {
      elem = arr.sample(1);
      res.push(elem);
      arr.remove(elem);
    }
    return res;
  };

  Array.prototype.shuffle = function() {
    var arr, elem, i, l, len1;
    arr = this.sample(this.length);
    for (i = l = 0, len1 = arr.length; l < len1; i = ++l) {
      elem = arr[i];
      this[i] = elem;
    }
    return this;
  };

  Array.prototype.average = function() {
    var elem, elems, l, len1, sum;
    sum = 0;
    elems = 0;
    for (l = 0, len1 = this.length; l < len1; l++) {
      elem = this[l];
      if (!(Math.isNum(elem))) {
        continue;
      }
      sum += elem;
      elems++;
    }
    return sum / elems;
  };

  Array.prototype.median = Array.prototype.average;

  Array.prototype.clone = Array.prototype.slice;

  Array.prototype.indexOfNative = Array.prototype.indexOf;

  Array.prototype.indexOf = function(elem, fromIdx) {
    var idx, len;
    idx = fromIdx != null ? fromIdx : 0;
    len = this.length;
    while (idx < len) {
      if (this[idx] === elem) {
        return idx;
      }
      idx++;
    }
    return -1;
  };

  Array.prototype.remove = function(elem) {
    var idx;
    idx = this.indexOf(elem);
    if (idx > -1) {
      this.splice(idx, 1);
    }
    return this;
  };

  Array.prototype.removeAll = function(elements) {
    var elem, l, len1;
    if (elements == null) {
      elements = [];
    }
    for (l = 0, len1 = elements.length; l < len1; l++) {
      elem = elements[l];
      this.remove(elem);
    }
    return this;
  };

  Array.prototype.removeAt = function(idx) {
    this.splice(idx, 1);
    return this;
  };

  Object.defineProperties(Array.prototype, {
    first: {
      get: function() {
        return this[0];
      },
      set: function(val) {
        this[0] = val;
        return this;
      }
    },
    second: {
      get: function() {
        return this[1];
      },
      set: function(val) {
        this[1] = val;
        return this;
      }
    },
    third: {
      get: function() {
        return this[2];
      },
      set: function(val) {
        this[2] = val;
        return this;
      }
    },
    fourth: {
      get: function() {
        return this[3];
      },
      set: function(val) {
        this[3] = val;
        return this;
      }
    },
    last: {
      get: function() {
        return this[this.length - 1];
      },
      set: function(val) {
        this[this.length - 1] = val;
        return this;
      }
    }
  });


  /**
   * @method getMax
   * @param {Function} propertyGetter
   * The passed callback extracts the value being compared from the array elements.
   * @return {Array} An array of all maxima.
  *
   */

  Array.prototype.getMax = function(propertyGetter) {
    var elem, l, len1, max, res, val;
    max = null;
    res = [];
    if (propertyGetter == null) {
      propertyGetter = function(item) {
        return item;
      };
    }
    for (l = 0, len1 = this.length; l < len1; l++) {
      elem = this[l];
      val = propertyGetter(elem);
      if (val > max || max === null) {
        max = val;
        res = [elem];
      } else if (val === max) {
        res.push(elem);
      }
    }
    return res;
  };

  Array.prototype.getMin = function(propertyGetter) {
    var elem, l, len1, min, res, val;
    min = null;
    res = [];
    if (propertyGetter == null) {
      propertyGetter = function(item) {
        return item;
      };
    }
    for (l = 0, len1 = this.length; l < len1; l++) {
      elem = this[l];
      val = propertyGetter(elem);
      if (val < min || min === null) {
        min = val;
        res = [elem];
      } else if (val === min) {
        res.push(elem);
      }
    }
    return res;
  };

  Array.prototype.sortProp = function(getProp, order) {
    var cmpFunc;
    if (order == null) {
      order = "asc";
    }
    if (getProp == null) {
      getProp = function(item) {
        return item;
      };
    }
    if (order === "asc") {
      cmpFunc = function(a, b) {
        a = getProp(a);
        b = getProp(b);
        if (a < b) {
          return -1;
        }
        if (b > a) {
          return 1;
        }
        return 0;
      };
    } else {
      cmpFunc = function(a, b) {
        a = getProp(a);
        b = getProp(b);
        if (a > b) {
          return -1;
        }
        if (b < a) {
          return 1;
        }
        return 0;
      };
    }
    return this.sort(cmpFunc);
  };

  String.prototype.camel = function(spaces) {
    var i, l, ref, str;
    if (spaces == null) {
      spaces = false;
    }
    str = this.toLowerCase();
    if (spaces) {
      str = str.split(" ");
      for (i = l = 1, ref = str.length; 1 <= ref ? l < ref : l > ref; i = 1 <= ref ? ++l : --l) {
        str[i] = str[i].charAt(0).toUpperCase() + str[i].substring(1);
      }
      str = str.join("");
    }
    return str;
  };

  String.prototype.antiCamel = function() {
    var i, l, ref, res, temp;
    res = this.charAt(0);
    for (i = l = 1, ref = this.length; 1 <= ref ? l < ref : l > ref; i = 1 <= ref ? ++l : --l) {
      temp = this.charAt(i);
      if (temp === temp.toUpperCase()) {
        res += " ";
      }
      res += temp;
    }
    return res;
  };

  String.prototype.firstToUpperCase = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  };

  String.prototype.snakeToCamelCase = function() {
    var char, l, len1, prevChar, res;
    res = "";
    for (l = 0, len1 = this.length; l < len1; l++) {
      char = this[l];
      if (char !== "_") {
        if (prevChar !== "_") {
          res += char;
        } else {
          res += char.toUpperCase();
        }
      }
      prevChar = char;
    }
    return res;
  };

  String.prototype.camelToSnakeCase = function() {
    var char, l, len1, prevChar, res;
    res = "";
    prevChar = null;
    for (l = 0, len1 = this.length; l < len1; l++) {
      char = this[l];
      if (char === char.toLowerCase()) {
        res += char;
      } else {
        if (prevChar === prevChar.toLowerCase()) {
          res += "_" + char.toLowerCase();
        } else {
          res += char;
        }
      }
      prevChar = char;
    }
    return res;
  };

  String.prototype.lower = String.prototype.toLowerCase;

  String.prototype.upper = String.prototype.toUpperCase;

  Object.defineProperties(String.prototype, {
    first: {
      get: function() {
        return this[0];
      },
      set: function(val) {
        return this;
      }
    },
    second: {
      get: function() {
        return this[1];
      },
      set: function(val) {
        return this;
      }
    },
    third: {
      get: function() {
        return this[2];
      },
      set: function(val) {
        return this;
      }
    },
    fourth: {
      get: function() {
        return this[3];
      },
      set: function(val) {
        return this;
      }
    },
    last: {
      get: function() {
        return this[this.length - 1];
      },
      set: function(val) {
        return this;
      }
    }
  });

  String.prototype.equals = function(str) {
    return this.valueOf() === str.valueOf();
  };

  String.prototype.lessThan = function(str) {
    return this.valueOf() < str.valueOf();
  };

  String.prototype.lt = String.prototype.lessThan;

  String.prototype.greaterThan = function(str) {
    return this.valueOf() > str.valueOf();
  };

  String.prototype.gt = String.prototype.greaterThan;

  String.prototype.lessThanOrEqualTo = function(str) {
    return this.valueOf() <= str.valueOf();
  };

  String.prototype.lte = String.prototype.lessThanOrEqualTo;

  String.prototype.greaterThanOrEqualTo = function(str) {
    return this.valueOf() >= str.valueOf();
  };

  String.prototype.gte;

  Boolean.prototype.equals = function(bool) {
    return this.valueOf() === bool.valueOf();
  };

  Boolean.prototype.lessThan = function(bool) {
    return this.valueOf() < bool.valueOf();
  };

  Boolean.prototype.lt = Boolean.prototype.lessThan;

  Boolean.prototype.greaterThan = function(bool) {
    return this.valueOf() > bool.valueOf();
  };

  Boolean.prototype.gt = Boolean.prototype.greaterThan;

  Boolean.prototype.lessThanOrEqualTo = function(bool) {
    return this.valueOf() <= bool.valueOf();
  };

  Boolean.prototype.lte = Boolean.prototype.lessThanOrEqualTo;

  Boolean.prototype.greaterThanOrEqualTo = function(bool) {
    return this.valueOf() >= str.valueOf();
  };

  Boolean.prototype.gte;

  Object.keysLike = function(obj, pattern) {
    var key, l, len1, ref, res;
    res = [];
    ref = Object.keys(obj);
    for (l = 0, len1 = ref.length; l < len1; l++) {
      key = ref[l];
      if (pattern.test(key)) {
        res.push(key);
      }
    }
    return res;
  };

  Object.defineProperties(mathJS, {
    e: {
      value: Math.E,
      writable: false
    },
    pi: {
      value: Math.PI,
      writable: false
    },
    ln2: {
      value: Math.LN2,
      writable: false
    },
    ln10: {
      value: Math.LN10,
      writable: false
    },
    log2e: {
      value: Math.LOG2E,
      writable: false
    },
    log10e: {
      value: Math.LOG10E,
      writable: false
    },
    infty: {
      value: Infinity,
      writable: false
    },
    infinity: {
      value: Infinity,
      writable: false
    },
    epsilon: {
      value: Number.EPSILON || 2.220446049250313e-16,
      writable: false
    },
    maxValue: {
      value: Number.MAX_VALUE,
      writable: false
    },
    minValue: {
      value: Number.MIN_VALUE,
      writable: false
    },
    id: {
      value: function(x) {
        return x;
      },
      writable: false
    }
  });

  mathJS.isPrimitive = function(x) {
    return typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  };

  mathJS.isComparable = function(x) {
    return x.equals instanceof Function || mathJS.isPrimitive(x);
  };

  mathJS.equals = function(x, y) {
    return (typeof x.equals === "function" ? x.equals(y) : void 0) || (typeof y.equals === "function" ? y.equals(x) : void 0) || x === y;
  };

  mathJS.greaterThan = function(x, y) {
    return (typeof x.gt === "function" ? x.gt(y) : void 0) || (typeof y.lt === "function" ? y.lt(x) : void 0) || x > y;
  };

  mathJS.gt = mathJS.greaterThan;

  mathJS.lessThan = function(x, y) {
    return (typeof x.lt === "function" ? x.lt(y) : void 0) || (typeof y.gt === "function" ? y.gt(x) : void 0) || x < y;
  };

  mathJS.lt = mathJS.lessThan;

  mathJS.ggT = function() {
    var ggt, i, l, ref, vals;
    if (arguments[0] instanceof Array) {
      vals = arguments[0];
    } else {
      vals = Array.prototype.slice.apply(arguments);
    }
    if (vals.length === 2) {
      if (vals[1] === 0) {
        return vals[0];
      }
      return mathJS.ggT(vals[1], modulo(vals[0], vals[1]));
    } else if (vals.length > 2) {
      ggt = mathJS.ggT(vals[0], vals[1]);
      for (i = l = 2, ref = vals.length; 2 <= ref ? l < ref : l > ref; i = 2 <= ref ? ++l : --l) {
        ggt = mathJS.ggT(ggt, vals[i]);
      }
      return ggt;
    }
    return null;
  };

  mathJS.gcd = mathJS.ggT;

  mathJS.kgV = function() {
    var i, kgv, l, ref, vals;
    if (arguments[0] instanceof Array) {
      vals = arguments[0];
    } else {
      vals = Array.prototype.slice.apply(arguments);
    }
    if (vals.length === 2) {
      return Math.floor(vals[0] * vals[1] / mathJS.ggT(vals[0], vals[1]));
    } else if (vals.length > 2) {
      kgv = mathJS.kgV(vals[0], vals[1]);
      for (i = l = 2, ref = vals.length; 2 <= ref ? l < ref : l > ref; i = 2 <= ref ? ++l : --l) {
        kgv = mathJS.kgV(kgv, vals[i]);
      }
      return kgv;
    }
    return null;
  };

  mathJS.lcm = mathJS.kgV;

  mathJS.coprime = function(x, y) {
    return mathJS.gcd(x, y) === 1;
  };

  mathJS.ceil = Math.ceil;

  mathJS.floor = function(n) {
    return ~~n;
  };

  mathJS.floatToInt = mathJS.floor;

  mathJS.square = function(n) {
    if (mathJS.isNum(n)) {
      return n * n;
    }
    return NaN;
  };

  mathJS.cube = function(n) {
    if (mathJS.isNum(n)) {
      return n * n * n;
    }
    return NaN;
  };

  mathJS.pow = Math.pow;

  mathJS.sqrt = Math.sqrt;

  mathJS.curt = function(n) {
    if (mathJS.isNum(n)) {
      return mathJS.pow(n, 1 / 3);
    }
    return NaN;
  };

  mathJS.root = function(n, exp) {
    if (mathJS.isNum(n) && mathJS.isNum(exp)) {
      return mathJS.pow(n, 1 / exp);
    }
    return NaN;
  };

  mathJS.factorial = function(n) {
    if ((n = ~~n) < 0) {
      return NaN;
    }
    return mathJS.factorial.cache[n] || (mathJS.factorial.cache[n] = n * mathJS.factorial(n - 1));
  };

  mathJS.factorial.cache = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 4.790016e8, 6.2270208e9, 8.71782912e10, 1.307674368e12];

  mathJS.fac = mathJS.factorial;

  mathJS.parseNumber = function(str) {
    return null;
  };

  mathJS.factorialInverse = function(n) {
    var x, y;
    if ((n = ~~n) < 0) {
      return NaN;
    }
    x = 0;
    while ((y = mathJS.factorial(++x)) < n) {}
    if (y === n) {
      return parseInt(x, 10);
    }
    return NaN;
  };

  mathJS.facInv = mathJS.factorialInverse;


  /**
   * This function checks if a given parameter is a (plain) number.
   * @method isNum
   * @param {Number} num
   * @return {Boolean} Whether the given number is a Number (excluding +/-Infinity)
  *
   */

  mathJS.isNum = function(n) {
    return (n != null) && isFinite(n);
  };

  mathJS.isMathJSNum = function(n) {
    return (n != null) && (isFinite(n) || n instanceof mathJS.Number || n["instanceof"](mathJS.Number));
  };

  mathJS.isInt = function(r) {
    return mathJS.isNum(r) && ~~r === r;
  };


  /**
   * This function returns a random (plain) integer between max and min (both inclusive). If max is less than min the parameters are swapped.
   * @method randInt
   * @param {Number} max
   * @param {Number} min
   * @return {Number} Random integer.
  *
   */

  mathJS.randInt = function(max, min) {
    if (max == null) {
      max = 1;
    }
    if (min == null) {
      min = 0;
    }
    return ~~mathJS.randNum(max, min);
  };


  /**
   * This function returns a random number between max and min (both inclusive). If max is less than min the parameters are swapped.
   * @method randNum
   * @param {Number} max
   * @param {Number} min
   * Default is 0.
   * @return {Integer} Random number.
  *
   */

  mathJS.randNum = function(max, min) {
    var temp;
    if (max == null) {
      max = 1;
    }
    if (min == null) {
      min = 0;
    }
    if (min > max) {
      temp = min;
      min = max;
      max = temp;
    }
    return Math.random() * (max + 1 - min) + min;
  };

  mathJS.radToDeg = function(rad) {
    return rad * 57.29577951308232;
  };

  mathJS.degToRad = function(deg) {
    return deg * 0.017453292519943295;
  };

  mathJS.sign = function(n) {
    n = n.value || n;
    if (mathJS.isNum(n)) {
      if (n < 0) {
        return -1;
      }
      return 1;
    }
    return NaN;
  };

  mathJS.min = function() {
    var elems, item, l, len1, min, propGetter, res;
    elems = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (elems.first instanceof Array) {
      elems = elems.first;
      propGetter = null;
    } else if (elems.first instanceof Function) {
      propGetter = elems.first;
      elems = elems.slice(1);
      if (elems.first instanceof Array) {
        elems = elems.first;
      }
    }
    res = [];
    min = null;
    for (l = 0, len1 = elems.length; l < len1; l++) {
      item = elems[l];
      if (propGetter != null) {
        item = propGetter(item);
      }
      if (min === null || item.lessThan(min) || item < min) {
        min = item;
        res = [elem];
      } else if (item.equals(min) || item === min) {
        res.push(elem);
      }
    }
    return res;
  };

  mathJS.max = function() {
    var elems, item, l, len1, max, propGetter, res;
    elems = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (elems.first instanceof Array) {
      elems = elems.first;
      propGetter = null;
    } else if (elems.first instanceof Function) {
      propGetter = elems.first;
      elems = elems.slice(1);
      if (elems.first instanceof Array) {
        elems = elems.first;
      }
    }
    res = [];
    max = null;
    for (l = 0, len1 = elems.length; l < len1; l++) {
      item = elems[l];
      if (propGetter != null) {
        item = propGetter(item);
      }
      if (max === null || item.greaterThan(max) || item > max) {
        max = item;
        res = [elem];
      } else if (item.equals(max) || item === max) {
        res.push(elem);
      }
    }
    return res;
  };

  mathJS.log = function(n, base) {
    if (base == null) {
      base = 10;
    }
    return Math.log(n) / Math.log(base);
  };

  mathJS.logBase = mathJS.log;

  mathJS.reciprocal = function(n) {
    if (mathJS.isNum(n)) {
      return 1 / n;
    }
    return NaN;
  };

  mathJS.sortFunction = function(a, b) {
    if (a.lessThan(b)) {
      return -1;
    }
    if (a.greaterThan(b)) {
      return 1;
    }
    return 0;
  };

  mathJS.settings = {
    generator: {
      maxIndex: 1e4
    },
    integral: {
      maxSteps: 1e10
    },
    maxPoolSize: 100,
    number: {
      real: {
        distance: 1e-6
      }
    },
    set: {
      defaultNumberOfElements: 1e3,
      maxIterations: 1e3,
      maxMatches: 60
    }
  };

  mathJS.config = mathJS.settings;


  /**
  * This is the super class of all mathJS classes.
  * Therefore all cross-class things are defined here.
  * @class Object
  *
   */

  _mathJS.Object = (function() {
    function Object() {}

    Object._implements = [];

    Object._implementedBy = [];

    Object["implements"] = function() {
      var classes, clss, clssPrototype, l, len1, method, name, prototypeKeys;
      classes = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (classes.first instanceof Array) {
        classes = classes.first;
      }
      for (l = 0, len1 = classes.length; l < len1; l++) {
        clss = classes[l];
        if (indexOf.call(clss._implementedBy, this) < 0) {
          clss._implementedBy.push(this);
        }
        clssPrototype = clss.prototype;
        prototypeKeys = window.Object.keys(clssPrototype);
        for (name in clss) {
          method = clss[name];
          if (indexOf.call(prototypeKeys, name) < 0) {
            this[name] = method;
          }
        }
        for (name in clssPrototype) {
          method = clssPrototype[name];
          this.prototype[name] = method;
        }
        this._implements.push(clss);
      }
      return this;
    };

    Object.prototype.isA = function(clss) {
      var c, l, len1, ref;
      if ((clss == null) || !(clss instanceof Function)) {
        return false;
      }
      if (this instanceof clss) {
        return true;
      }
      ref = this.constructor._implements;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        c = ref[l];
        if (c === clss) {
          return true;
        }
        while ((c = c.__superClass__) != null) {
          if (c === clss) {
            return true;
          }
        }
      }
      return false;
    };

    Object.prototype["instanceof"] = function() {
      return this.isA.apply(this, arguments);
    };

    return Object;

  })();

  mathJS.Errors.CalculationExceedanceError = (function(superClass) {
    extend(CalculationExceedanceError, superClass);

    function CalculationExceedanceError() {
      return CalculationExceedanceError.__super__.constructor.apply(this, arguments);
    }

    return CalculationExceedanceError;

  })(Error);

  mathJS.Errors.InvalidVariableError = (function(superClass) {
    extend(InvalidVariableError, superClass);

    function InvalidVariableError() {
      return InvalidVariableError.__super__.constructor.apply(this, arguments);
    }

    return InvalidVariableError;

  })(Error);

  mathJS.Errors.InvalidParametersError = (function(superClass) {
    extend(InvalidParametersError, superClass);

    function InvalidParametersError() {
      return InvalidParametersError.__super__.constructor.apply(this, arguments);
    }

    return InvalidParametersError;

  })(Error);

  mathJS.Errors.InvalidArityError = (function(superClass) {
    extend(InvalidArityError, superClass);

    function InvalidArityError() {
      return InvalidArityError.__super__.constructor.apply(this, arguments);
    }

    return InvalidArityError;

  })(Error);

  mathJS.Errors.NotImplementedError = (function(superClass) {
    extend(NotImplementedError, superClass);

    function NotImplementedError() {
      return NotImplementedError.__super__.constructor.apply(this, arguments);
    }

    return NotImplementedError;

  })(Error);

  mathJS.Errors.CycleDetectedError = (function(superClass) {
    extend(CycleDetectedError, superClass);

    function CycleDetectedError() {
      return CycleDetectedError.__super__.constructor.apply(this, arguments);
    }

    return CycleDetectedError;

  })(Error);


  /**
   * This is an implementation of a dictionary/hash that does not convert its keys into Strings. Keys can therefore actually by anything!
   * @class Hash
   * @constructor
  *
   */

  mathJS.Utils.Hash = (function() {

    /**
     * Creates a new Hash from a given JavaScript object.
     * @static
     * @method fromObject
     * @param object {Object}
    *
     */
    Hash.fromObject = function(obj) {
      return new mathJS.Utils.Hash(obj);
    };

    Hash["new"] = function(obj) {
      return new mathJS.Utils.Hash(obj);
    };

    function Hash(obj) {
      var key, val;
      this.keys = [];
      this.values = [];
      if (obj != null) {
        for (key in obj) {
          val = obj[key];
          this.put(key, val);
        }
      }
    }

    Hash.prototype.clone = function() {
      var res;
      res = new mathJS.Utils.Hash();
      res.keys = this.keys.clone();
      res.values = this.values.clone();
      return res;
    };

    Hash.prototype.invert = function() {
      var res;
      res = new mathJS.Utils.Hash();
      res.keys = this.values.clone();
      res.values = this.keys.clone();
      return res;
    };


    /**
     * Adds a new key-value pair or overwrites an existing one.
     * @method put
     * @param key {mixed}
     * @param val {mixed}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    Hash.prototype.put = function(key, val) {
      var idx;
      idx = this.keys.indexOf(key);
      if (idx < 0) {
        this.keys.push(key);
        this.values.push(val);
      } else {
        this.keys[idx] = key;
        this.values[idx] = val;
      }
      return this;
    };


    /**
     * Returns the value (or null) for the specified key.
     * @method get
     * @param key {mixed}
     * @param [equalityFunction] {Function}
     * This optional function can overwrite the test for equality between keys. This function expects the parameters: (the current key in the key iteration, 'key'). If this parameters is omitted '===' is used.
     * @return {mixed}
    *
     */

    Hash.prototype.get = function(key) {
      var idx;
      if ((idx = this.keys.indexOf(key)) >= 0) {
        return this.values[idx];
      }
      return null;
    };


    /**
     * Indicates whether the Hash has the specified key.
     * @method hasKey
     * @param key {mixed}
     * @return {Boolean}
    *
     */

    Hash.prototype.hasKey = function(key) {
      return indexOf.call(this.keys, key) >= 0;
    };

    Hash.prototype.has = function(key) {
      return this.hasKey(key);
    };


    /**
     * Returns the number of entries in the Hash.
     * @method size
     * @return {Integer}
    *
     */

    Hash.prototype.size = function() {
      return this.keys.length;
    };

    Hash.prototype.empty = function() {
      this.keys = [];
      this.values = [];
      return this;
    };

    Hash.prototype.remove = function(key) {
      var idx;
      if ((idx = this.keys.indexOf(key)) >= 0) {
        this.keys.splice(idx, 1);
        this.values.splice(idx, 1);
      } else {
        console.warn("Could not remove key '" + key + "'!");
      }
      return this;
    };

    Hash.prototype.each = function(callback) {
      var i, key, l, len1, ref;
      ref = this.keys;
      for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
        key = ref[i];
        if (callback(key, this.values[i], i) === false) {
          return this;
        }
      }
      return this;
    };

    return Hash;

  })();

  mathJS.Utils.Dispatcher = (function(superClass) {
    extend(Dispatcher, superClass);

    Dispatcher.registeredDispatchers = mathJS.Utils.Hash["new"]();

    Dispatcher.registerDispatcher = function(newReceiver, newTargets) {
      var regReceivers, registrationPossible;
      registrationPossible = true;
      regReceivers = this.registeredDispatchers.keys;
      this.registeredDispatchers.each(function(regReceiver, regTargets, idx) {
        var l, len1, len2, newTarget, o, regTarget;
        for (l = 0, len1 = regTargets.length; l < len1; l++) {
          regTarget = regTargets[l];
          if (regTarget === newReceiver) {
            for (o = 0, len2 = newTargets.length; o < len2; o++) {
              newTarget = newTargets[o];
              if (!(regReceivers.indexOf(newTarget))) {
                continue;
              }
              registrationPossible = false;
              return false;
            }
          }
        }
        return true;
      });
      if (registrationPossible) {
        this.registeredDispatchers.put(newReceiver, newTargets);
        return this;
      }
      throw new mathJS.Errors.CycleDetectedError("Can't register '" + newReceiver + "' for dispatching - cycle detected!");
    };

    function Dispatcher(receiver, targets) {
      if (targets == null) {
        targets = [];
      }
      this.constructor.registerDispatcher(receiver, targets);
      this.receiver = receiver;
      this.targets = targets;
    }

    Dispatcher.prototype.dispatch = function() {
      var dispatch, l, len1, method, params, ref, t, target;
      target = arguments[0], method = arguments[1], params = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      dispatch = false;
      if (this.targets.indexOf(target.constructor || target) >= 0) {
        dispatch = true;
      } else {
        ref = this.targets;
        for (l = 0, len1 = ref.length; l < len1; l++) {
          t = ref[l];
          if (!(typeof target === t)) {
            continue;
          }
          dispatch = true;
          break;
        }
      }
      if (dispatch) {
        if (target[method] instanceof Function) {
          return target[method].apply(target, params);
        }
        throw new mathJS.Errors.NotImplementedError("Can't call '" + method + "' on target '" + target + "'", "Dispatcher.coffee", void 0, target);
      }
      return null;
    };

    return Dispatcher;

  })(_mathJS.Object);

  _mathJS.Interface = (function(superClass) {
    extend(Interface, superClass);

    function Interface() {
      return Interface.__super__.constructor.apply(this, arguments);
    }

    Interface.implementedBy = [];

    Interface.isImplementedBy = function() {
      return this.implementedBy;
    };

    return Interface;

  })(_mathJS.Object);

  _mathJS.Comparable = (function(superClass) {
    extend(Comparable, superClass);

    function Comparable() {
      return Comparable.__super__.constructor.apply(this, arguments);
    }


    /**
    * This method checks for mathmatical equality. This means new mathJS.Double(4.2).equals(4.2) is true.
    * @method equals
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Comparable.prototype.equals = function(n) {
      throw new mathJS.Errors.NotImplementedError("equals in " + this.contructor.name);
    };

    Comparable.prototype.e = function() {
      return this.equals.apply(this, arguments);
    };

    return Comparable;

  })(_mathJS.Interface);

  _mathJS.Orderable = (function(superClass) {
    extend(Orderable, superClass);

    function Orderable() {
      return Orderable.__super__.constructor.apply(this, arguments);
    }


    /**
    * This method checks for mathmatical "<". This means new mathJS.Double(4.2).lessThan(5.2) is true.
    * @method lessThan
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Orderable.prototype.lessThan = function(n) {
      throw new mathJS.Errors.NotImplementedError("lessThan in " + this.contructor.name);
    };


    /**
    * Alias for `lessThan`.
    * @method lt
    *
     */

    Orderable.prototype.lt = function() {
      return this.lessThan.apply(this, arguments);
    };


    /**
    * This method checks for mathmatical ">". This means new mathJS.Double(4.2).greaterThan(3.2) is true.
    * @method greaterThan
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Orderable.prototype.greaterThan = function(n) {
      throw new mathJS.Errors.NotImplementedError("greaterThan in " + this.contructor.name);
    };


    /**
    * Alias for `greaterThan`.
    * @method gt
    *
     */

    Orderable.prototype.gt = function() {
      return this.greaterThan.apply(this, arguments);
    };


    /**
    * This method checks for mathmatical "<=". This means new mathJS.Double(4.2).lessThanOrEqualTo(5.2) is true.
    * @method lessThanOrEqualTo
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Orderable.prototype.lessThanOrEqualTo = function(n) {
      throw new mathJS.Errors.NotImplementedError("lessThanOrEqualTo in " + this.contructor.name);
    };


    /**
    * Alias for `lessThanOrEqualTo`.
    * @method lte
    *
     */

    Orderable.prototype.lte = function() {
      return this.lessThanOrEqualTo.apply(this, arguments);
    };


    /**
    * This method checks for mathmatical ">=". This means new mathJS.Double(4.2).greaterThanOrEqualTo(3.2) is true.
    * @method greaterThanOrEqualTo
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Orderable.prototype.greaterThanOrEqualTo = function(n) {
      throw new mathJS.Errors.NotImplementedError("greaterThanOrEqualTo in " + this.contructor.name);
    };


    /**
    * Alias for `greaterThanOrEqualTo`.
    * @method gte
    *
     */

    Orderable.prototype.gte = function() {
      return this.greaterThanOrEqualTo.apply(this, arguments);
    };

    return Orderable;

  })(_mathJS.Comparable);

  _mathJS.Parseable = (function(superClass) {
    extend(Parseable, superClass);

    function Parseable() {
      return Parseable.__super__.constructor.apply(this, arguments);
    }

    Parseable.parse = function(str) {
      throw new mathJS.Errors.NotImplementedError("static parse in " + this.name);
    };

    Parseable.fromString = function(str) {
      return this.parse(str);
    };

    Parseable.prototype.toString = function(args) {
      throw new mathJS.Errors.NotImplementedError("toString in " + this.contructor.name);
    };

    return Parseable;

  })(_mathJS.Interface);

  _mathJS.Poolable = (function(superClass) {
    extend(Poolable, superClass);

    function Poolable() {
      return Poolable.__super__.constructor.apply(this, arguments);
    }

    Poolable._pool = [];

    Poolable._fromPool = function() {
      throw new mathJS.Errors.NotImplementedError("static _fromPool in " + this.name);
    };


    /**
    * Releases the instance to the pool of its class.
    * @method release
    * @return This intance
    * @chainable
    *
     */

    Poolable.prototype.release = function() {
      if (this.constructor._pool.length < mathJS.settings.maxPoolSize) {
        this.constructor._pool.push(this);
      }
      if (DEBUG) {
        if (this.constructor._pool.length >= mathJS.settings.maxPoolSize) {
          console.warn(this.constructor.name + "-pool is full:", this.constructor._pool);
        }
      }
      return this;
    };

    return Poolable;

  })(_mathJS.Interface);

  _mathJS.Evaluable = (function(superClass) {
    extend(Evaluable, superClass);

    function Evaluable() {
      return Evaluable.__super__.constructor.apply(this, arguments);
    }

    Evaluable.prototype["eval"] = function() {
      throw new mathJS.Errors.NotImplementedError("eval() in " + this.contructor.name);
    };

    return Evaluable;

  })(_mathJS.Interface);

  _mathJS.AbstractNumber = (function(superClass) {
    extend(AbstractNumber, superClass);

    function AbstractNumber() {
      return AbstractNumber.__super__.constructor.apply(this, arguments);
    }

    AbstractNumber["implements"](_mathJS.Orderable, _mathJS.Poolable, _mathJS.Parseable);


    /**
    * @Override mathJS.Poolable
    * @static
    * @method _fromPool
    *
     */

    AbstractNumber._fromPool = function(value) {
      var number, val;
      if (this._pool.length > 0) {
        if ((val = this._getPrimitive(value)) != null) {
          number = this._pool.pop();
          number.value = val.value || val;
          return number;
        }
        throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + value + "'", "AbstractNumber.coffee", void 0, value);
      }
      return new this(value);
    };


    /**
    * @Override mathJS.Parseable
    * @static
    * @method parse
    *
     */

    AbstractNumber.parse = function(str) {
      return this._fromPool(parseFloat(str));
    };

    AbstractNumber.getSet = function() {
      throw new mathJS.Errors.NotImplementedError("getSet in " + this.name);
    };

    AbstractNumber["new"] = function(param) {
      return this._fromPool(param);
    };

    AbstractNumber.random = function(max, min) {
      return this._fromPool(mathJS.randNum(max, min));
    };

    AbstractNumber.dispatcher = new mathJS.Utils.Dispatcher(AbstractNumber, ["string"]);


    /**
    * This method is used to parse and check a parameter.
    * Either a valid value is returned or null (for invalid parameters).
    * @static
    * @method _getPrimitive
    * @param param {Object}
    * @param skipCheck {Boolean}
    * @return {mathJS.Number}
    *
     */

    AbstractNumber._getPrimitive = function(param, skipCheck) {
      return null;
    };

    AbstractNumber.prototype._setValue = function(value) {
      return this;
    };

    AbstractNumber.prototype._getValue = function() {
      return this._value;
    };

    AbstractNumber.prototype._getPrimitive = function(param) {
      return this.constructor._getPrimitive(param);
    };


    /**
    * @Override mathJS.Comparable
    * This method checks for mathmatical equality. This means new mathJS.Double(4.2).equals(4.2) is true.
    * @method equals
    * @param {Number} n
    * @return {Boolean}
    *
     */

    AbstractNumber.prototype.equals = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return this.value === val;
      }
      return false;
    };


    /**
    * @Override mathJS.Orderable
    * This method checks for mathmatical "<". This means new mathJS.Double(4.2).lessThan(5.2) is true.
    * @method lessThan
    *
     */

    AbstractNumber.prototype.lessThan = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return this.value < val;
      }
      return false;
    };


    /**
    * @Override mathJS.Orderable
    * This method checks for mathmatical ">". This means new mathJS.Double(4.2).greaterThan(3.2) is true.
    * @method greaterThan
    * @param {Number} n
    * @return {Boolean}
    *
     */

    AbstractNumber.prototype.greaterThan = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return this.value > val;
      }
      return false;
    };


    /**
    * @Override mathJS.Orderable
    * This method checks for mathmatical "<=".
    * @method lessThanOrEqualTo
    * @param {Number} n
    * @return {Boolean}
    *
     */

    AbstractNumber.prototype.lessThanOrEqualTo = function(n) {
      return this.lessThan(n) || this.equals(n);
    };


    /**
    * This method checks for mathmatical ">=".
    * @method greaterThanOrEqualTo
    * @param {Number} n
    * @return {Boolean}
    *
     */

    AbstractNumber.prototype.greaterThanOrEqualTo = function(n) {
      return this.greaterThan(n) || this.equals(n);
    };


    /**
    * This method adds 2 numbers and returns a new one.
    * @method plus
    * @param {Number} n
    * @return {mathJS.Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.plus = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return mathJS.Number["new"](this.value + val);
      }
      throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + n + "'", "AbstractNumber.coffee", void 0, n);
    };


    /**
    * This method substracts 2 numbers and returns a new one.
    * @method minus
    * @param {Number} n
    * @return {mathJS.Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.minus = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return mathJS.Number["new"](this.value - val);
      }
      throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + n + "'", "AbstractNumber.coffee", void 0, n);
    };


    /**
    * This method multiplies 2 numbers and returns a new one.
    * @method times
    * @param {Number} n
    * @return {mathJS.Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.times = function(n) {
      var result, val;
      if ((result = this.constructor.dispatcher.dispatch(n, "times", this)) != null) {
        return result;
      }
      if ((val = this._getPrimitive(n)) != null) {
        return mathJS.Number["new"](this.value * val);
      }
      throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + n + "'", "AbstractNumber.coffee", void 0, n);
    };


    /**
    * This method divides 2 numbers and returns a new one.
    * @method divide
    * @param {Number} n
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.divide = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return mathJS.Number["new"](this.value / val);
      }
      throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + n + "'", "AbstractNumber.coffee", void 0, n);
    };


    /**
    * This method squares this instance and returns a new one.
    * @method square
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.square = function() {
      return mathJS.Number["new"](this.value * this.value);
    };


    /**
    * This method cubes this instance and returns a new one.
    * @method cube
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.cube = function() {
      return mathJS.Number["new"](this.value * this.value * this.value);
    };


    /**
    * This method calculates the square root of this instance and returns a new one.
    * @method sqrt
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.sqrt = function() {
      return mathJS.Number["new"](mathJS.sqrt(this.value));
    };


    /**
    * This method calculates the cubic root of this instance and returns a new one.
    * @method curt
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.curt = function() {
      return this.pow(0.3333333333333333);
    };


    /**
    * This method calculates any root of this instance and returns a new one.
    * @method root
    * @param {Number} exponent
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.root = function(exp) {
      var val;
      if ((val = this._getPrimitive(exp)) != null) {
        return this.pow(1 / val);
      }
      throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + exp + "'", "AbstractNumber.coffee", void 0, exp);
    };


    /**
    * This method returns the reciprocal (1/n) of this number.
    * @method reciprocal
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.reciprocal = function() {
      return mathJS.Number["new"](1 / this.value);
    };


    /**
    * This method returns this' value the the n-th power (this^n).
    * @method pow
    * @param {Number} n
    * @return {Number} Calculated Number.
    *
     */

    AbstractNumber.prototype.pow = function(n) {
      var val;
      if ((val = this._getPrimitive(n)) != null) {
        return mathJS.Number["new"](mathJS.pow(this.value, val));
      }
      throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + n + "'", "AbstractNumber.coffee", void 0, n);
    };


    /**
    * This method returns the sign of this number (sign(this)).
    * @method sign
    * @param plain {Boolean}
    * Indicates whether the return value is wrapped in a mathJS.Number or not (-> primitive value).
    * @return {Number|mathJS.Number}
    *
     */

    AbstractNumber.prototype.sign = function(plain) {
      var val;
      if (plain == null) {
        plain = true;
      }
      val = this.value;
      if (plain === true) {
        if (val < 0) {
          return -1;
        }
        return 1;
      }
      if (val < 0) {
        return mathJS.Number["new"](-1);
      }
      return mathJS.Number["new"](1);
    };

    AbstractNumber.prototype.negate = function() {
      return mathJS.Number["new"](-this.value);
    };

    AbstractNumber.prototype.toInt = function() {
      return mathJS.Int["new"](this.value);
    };

    AbstractNumber.prototype.toNumber = function() {
      return mathJS.Number["new"](this.value);
    };

    AbstractNumber.prototype.toString = function(format) {
      if (format == null) {
        return "" + this.value;
      }
      return numeral(this.value).format(format);
    };

    AbstractNumber.prototype.clone = function() {
      return mathJS.Number["new"](this.value);
    };

    AbstractNumber.prototype["eval"] = function(values) {
      return this;
    };

    AbstractNumber.prototype._getSet = function() {
      return new mathJS.Set(this);
    };

    AbstractNumber.prototype["in"] = function(set) {
      return set.contains(this);
    };

    return AbstractNumber;

  })(_mathJS.Object);


  /**
   * @abstract
   * @class Number
   * @constructor
   * @param {Number} value
   * @extends Object
  *
   */

  mathJS.Number = (function(superClass) {
    extend(Number, superClass);

    Number._getPrimitive = function(param, skipCheck) {
      if (skipCheck === true) {
        return param;
      }
      if (param instanceof mathJS.Number) {
        return param.value;
      }
      if (param instanceof Number) {
        return param.valueOf();
      }
      if (mathJS.isNum(param)) {
        return param;
      }
      return null;
    };

    Number.getSet = function() {
      return mathJS.Domains.R;
    };

    function Number(value) {
      var val;
      this._value = null;
      Object.defineProperties(this, {
        value: {
          get: this._getValue,
          set: this._setValue
        }
      });
      if ((val = this._getPrimitive(value)) != null) {
        this._value = val;
      } else {
        throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + value + "'", "Number.coffee", void 0, value);
      }
    }

    Number.prototype["eval"] = function(values) {
      return this;
    };

    Number.prototype._getSet = function() {
      return new mathJS.Set(this);
    };

    Number.prototype["in"] = function(set) {
      return set.contains(this);
    };

    Number.prototype.valueOf = Number.prototype._getValue;

    return Number;

  })(_mathJS.AbstractNumber);

  mathJS.Double = (function(superClass) {
    extend(Double, superClass);

    function Double() {
      return Double.__super__.constructor.apply(this, arguments);
    }

    return Double;

  })(mathJS.Number);


  /**
   * @class Int
   * @constructor
   * @param {Number} value
   * @extends Number
  *
   */

  mathJS.Int = (function(superClass) {
    extend(Int, superClass);

    Int.parse = function(str) {
      var parsed;
      if (mathJS.isNum(parsed = parseInt(str, 10))) {
        return this._fromPool(parsed);
      }
      return parsed;
    };

    Int.random = function(max, min) {
      return this._fromPool(mathJS.randInt(max, min));
    };

    Int.getSet = function() {
      return mathJS.Domains.N;
    };


    /**
    * @Override mathJS.Poolable
    * @static
    * @method _fromPool
    *
     */

    Int._fromPool = function(value) {
      var number, val;
      if (this._pool.length > 0) {
        if ((val = this._getPrimitiveInt(value)) != null) {
          number = this._pool.pop();
          number.value = val.value || val;
          return number;
        }
        throw new mathJS.Errors.InvalidParametersError("Can't instatiate number from given '" + value + "'", "Int.coffee", void 0, value);
      }
      return new this(value);
    };

    Int._getPrimitiveInt = function(param, skipCheck) {
      if (skipCheck === true) {
        return param;
      }
      if (param instanceof mathJS.Int) {
        return param.value;
      }
      if (param instanceof mathJS.Number) {
        return ~~param.value;
      }
      if (param instanceof Number) {
        return ~~param.valueOf();
      }
      if (mathJS.isNum(param)) {
        return ~~param;
      }
      return null;
    };

    function Int(value) {
      Int.__super__.constructor.apply(this, arguments);
    }

    Int.prototype.isEven = function() {
      return modulo(this.value, 2) === 0;
    };

    Int.prototype.isOdd = function() {
      return modulo(this.value, 2) === 1;
    };

    Int.prototype.toInt = function() {
      return mathJS.Int._fromPool(this.value);
    };

    Int.prototype.getSet = function() {
      return mathJS.Domains.N;
    };

    return Int;

  })(mathJS.Number);

  mathJS.Fraction = (function(superClass) {
    extend(Fraction, superClass);


    /**
    * @Override mathJS.Number
    * @static
    * @method _fromPool
    *
     */

    Fraction._fromPool = function(e, d) {
      var frac;
      if (this._pool.length > 0) {
        if (this.valueIsValid(val)) {
          frac = this._pool.pop();
          frac.enumerator = e.value || e;
          frac.denominator = d.value || d;
          return frac;
        }
        return null;
      } else {
        return new this(e, d);
      }
    };


    /**
    * @Override mathJS.Number
    * @static
    * @method parse
    *
     */

    Fraction.parse = function(str) {
      var parts;
      if (indexOf.call(str, "/") >= 0) {
        parts = str.split("/");
      } else if (indexOf.call(str, ":") >= 0) {
        parts = str.slit(":");
      }
      return this["new"](parts.first, parts.second);
    };


    /**
    * @Override mathJS.Number
    * @static
    * @method getSet
    *
     */

    Fraction.getSet = function() {
      return mathJS.Domains.Q;
    };


    /**
    * @Override mathJS.Number
    * @static
    * @method new
    *
     */

    Fraction["new"] = function(e, d) {
      return this._fromPool(e, d);
    };

    function Fraction(enumerator, denominator) {
      if (enumerator instanceof mathJS.Number && denominator instanceof mathJS.Number) {
        this.enumerator = enumerator.toInt();
        this.denominator = denominator.toInt();
      } else {
        this.enumerator = ~~enumerator;
        this.denominator = ~~denominator;
      }
    }

    return Fraction;

  })(mathJS.Number);


  /**
   * @abstract
   * @class Complex
   * @constructor
   * @param {Number} real
   * Real part of the number. Either a mathJS.Number or primitive number.
   * @param {Number} image
   * Real part of the number. Either a mathJS.Number or primitive number.
   * @extends Number
  *
   */

  mathJS.Complex = (function(superClass) {
    var PARSE_KEY;

    extend(Complex, superClass);

    PARSE_KEY = "0c";


    /**
    * @Override
    * This method creates an object with the keys "real" and "img" which have primitive numbers as their values.
    * @static
    * @method _getValueFromParam
    * @param {Complex|Number} real
    * @param {Number} img
    * @return {Object}
    *
     */

    Complex._getValueFromParam = function(real, img) {
      if (real instanceof mathJS.Complex) {
        return {
          real: real.real,
          img: real.img
        };
      }
      if (real instanceof mathJS.Number && img instanceof mathJS.Number) {
        return {
          real: real.value,
          img: img.value
        };
      }
      if (mathJS.isNum(real) && mathJS.isNum(img)) {
        return {
          real: real,
          img: img
        };
      }
      return null;
    };

    Complex._fromPool = function(real, img) {
      var number;
      if (this._pool.length > 0) {
        if (this._valueIsValid(real) && this._valueIsValid(img)) {
          number = this._pool.pop();
          number.real = real;
          number.img = img;
          return number;
        }
        return null;
      } else {
        return new this(real, img);
      }
    };

    Complex.parse = function(str) {
      var idx, img, parts, real;
      idx = str.toLowerCase().indexOf(PARSE_KEY);
      if (idx >= 0) {
        parts = str.substring(idx + PARSE_KEY.length).split(",");
        if (mathJS.isNum(real = parseFloat(parts[0])) && mathJS.isNum(img = parseFloat(parts[1]))) {
          return this._fromPool(real, img);
        }
      }
      return NaN;
    };

    Complex.random = function(max1, min1, max2, min2) {
      return this._fromPool(mathJS.randNum(max1, min1), mathJS.randNum(max2, min2));
    };

    function Complex(real, img) {
      var values;
      values = this._getValueFromParam(real, img);
      Object.defineProperties(this, {
        real: {
          get: this._getReal,
          set: this._setReal
        },
        img: {
          get: this._getImg,
          set: this._setImg
        },
        _fromPool: {
          value: this.constructor._fromPool.bind(this.constructor),
          writable: false,
          enumarable: false,
          configurable: false
        }
      });
      this.real = values.real;
      this.img = values.img;
    }

    Complex.prototype._setReal = function(value) {
      if (this._valueIsValid(value)) {
        this._real = value.value || value.real || value;
      }
      return this;
    };

    Complex.prototype._getReal = function() {
      return this._real;
    };

    Complex.prototype._setImg = function(value) {
      if (this._valueIsValid(value)) {
        this._img = value.value || value.img || value;
      }
      return this;
    };

    Complex.prototype._getImg = function() {
      return this._img;
    };

    Complex.prototype._getValueFromParam = Complex._getValueFromParam;


    /**
    * This method check for mathmatical equality. This means new mathJS.Double(4.2).equals(4.2)
    * @method equals
    * @param {Number} n
    * @return {Boolean}
    *
     */

    Complex.prototype.equals = function(r, i) {
      var values;
      values = this._getValueFromParam(r, i);
      if (values != null) {
        return this.real === values.real && this.img === values.img;
      }
      return false;
    };

    Complex.prototype.plus = function(r, i) {
      var values;
      values = this._getValueFromParam(r, i);
      if (values != null) {
        return this._fromPool(this.real + values.real, this.img + values.img);
      }
      return NaN;
    };

    Complex.prototype.increase = function(r, i) {
      var values;
      values = this._getValueFromParam(r, i);
      if (values != null) {
        this.real += values.real;
        this.img += values.img;
      }
      return this;
    };

    Complex.prototype.plusSelf = Complex.increase;

    Complex.prototype.minus = function(n) {
      var values;
      values = this._getValueFromParam(r, i);
      if (values != null) {
        return this._fromPool(this.real - values.real, this.img - values.img);
      }
      return NaN;
    };

    Complex.prototype.decrease = function(n) {
      var values;
      values = this._getValueFromParam(r, i);
      if (values != null) {
        this.real -= values.real;
        this.img -= values.img;
      }
      return this;
    };

    Complex.prototype.minusSelf = Complex.decrease;

    Complex.prototype.times = function(r, i) {
      var values;
      values = this._getValueFromParam(r, i);
      if (values != null) {
        return this._fromPool(this.real * values.real, this.img * values.img);
      }
      return NaN;
    };

    Complex.prototype.timesSelf = function(n) {
      this.value *= _getValueFromParam(n);
      return this;
    };

    Complex.prototype.divide = function(n) {
      return this._fromPool(this.value / _getValueFromParam(n));
    };

    Complex.prototype.divideSelf = function(n) {
      this.value /= _getValueFromParam(n);
      return this;
    };

    Complex.prototype.square = function() {
      return this._fromPool(this.value * this.value);
    };

    Complex.prototype.squareSelf = function() {
      this.value *= this.value;
      return this;
    };

    Complex.prototype.cube = function() {
      return this._fromPool(this.value * this.value * this.value);
    };

    Complex.prototype.squareSelf = function() {
      this.value *= this.value * this.value;
      return this;
    };

    Complex.prototype.sqrt = function() {
      return this._fromPool(mathJS.sqrt(this.value));
    };

    Complex.prototype.sqrtSelf = function() {
      this.value = mathJS.sqrt(this.value);
      return this;
    };

    Complex.prototype.pow = function(n) {
      return this._fromPool(mathJS.pow(this.value, _getValueFromParam(n)));
    };

    Complex.prototype.powSelf = function(n) {
      this.value = mathJS.pow(this.value, _getValueFromParam(n));
      return this;
    };

    Complex.prototype.sign = function() {
      return mathJS.sign(this.value);
    };

    Complex.prototype.toInt = function() {
      return mathJS.Int._fromPool(mathJS.floor(this.value));
    };

    Complex.prototype.toDouble = function() {
      return mathJS.Double._fromPool(this.value);
    };

    Complex.prototype.toString = function() {
      return "" + PARSE_KEY + (this.real.toString()) + "," + (this.img.toString());
    };

    Complex.prototype.clone = function() {
      return this._fromPool(this.value);
    };

    Complex.prototype.release = function() {
      this.constructor._pool.push(this);
      return this.constructor;
    };

    return Complex;

  })(mathJS.Number);

  mathJS.Algorithms.ShuntingYard = (function() {
    var CLASS, isOperand;

    CLASS = ShuntingYard;

    ShuntingYard.specialOperators = {
      "+": "#",
      "-": "_"
    };

    ShuntingYard.init = function() {
      return this.specialOperations = {
        "#": mathJS.Operations.neutralPlus,
        "_": mathJS.Operations.negate
      };
    };

    function ShuntingYard(settings) {
      var op, opSettings;
      this.ops = "";
      this.precedence = {};
      this.associativity = {};
      for (op in settings) {
        opSettings = settings[op];
        this.ops += op;
        this.precedence[op] = opSettings.precedence;
        this.associativity[op] = opSettings.associativity;
      }
    }

    isOperand = function(token) {
      return mathJS.isNum(token);
    };

    ShuntingYard.prototype.toPostfix = function(str) {
      var associativity, i, l, len1, o1, o2, ops, postfix, precedence, prevToken, stack, token;
      str = str.replace(/\s+/g, "");
      str = str.replace(/(\d+|\w)(\w)/g, "$1*$2");
      stack = [];
      ops = this.ops;
      precedence = this.precedence;
      associativity = this.associativity;
      postfix = "";
      postfix.postfix = true;
      for (i = l = 0, len1 = str.length; l < len1; i = ++l) {
        token = str[i];
        if (indexOf.call(ops, token) >= 0) {
          o1 = token;
          o2 = stack.last();
          if (i === 0 || prevToken === "(") {
            if (CLASS.specialOperators[token] != null) {
              postfix += CLASS.specialOperators[token] + " ";
            }
          } else {
            while (indexOf.call(ops, o2) >= 0 && (associativity[o1] === "left" && precedence[o1] <= precedence[o2]) || (associativity[o1] === "right" && precedence[o1] < precedence[o2])) {
              postfix += o2 + " ";
              stack.pop();
              o2 = stack.last();
            }
            stack.push(o1);
          }
        } else if (token === "(") {
          stack.push(token);
        } else if (token === ")") {
          while (stack.last() !== "(") {
            postfix += (stack.pop()) + " ";
          }
          stack.pop();
        } else {
          postfix += token + " ";
        }
        prevToken = token;
      }
      while (stack.length > 0) {
        postfix += (stack.pop()) + " ";
      }
      return postfix.trim();
    };

    ShuntingYard.prototype.toExpression = function(str) {
      var endIdx, exp, i, idxOffset, j, k, l, len1, op, ops, param, params, postfix, ref, startIdx, token, v;
      if (str.postfix == null) {
        postfix = this.toPostfix(str);
      } else {
        postfix = str;
      }
      postfix = postfix.split(" ");
      ops = this.ops;
      ref = CLASS.specialOperators;
      for (k in ref) {
        v = ref[k];
        ops += v;
      }
      i = 0;
      while (postfix.length > 1) {
        token = postfix[i];
        idxOffset = 0;
        if (indexOf.call(ops, token) >= 0) {
          if ((op = mathJS.Operations[token])) {
            startIdx = i - op.arity;
            endIdx = i;
          } else if ((op = CLASS.specialOperations[token])) {
            startIdx = i + 1;
            endIdx = i + op.arity + 1;
            idxOffset = -1;
          }
          params = postfix.slice(startIdx, endIdx);
          startIdx += idxOffset;
          for (j = l = 0, len1 = params.length; l < len1; j = ++l) {
            param = params[j];
            if (typeof param === "string") {
              if (isOperand(param)) {
                params[j] = new mathJS.Expression(parseFloat(param));
              } else {
                params[j] = new mathJS.Variable(param);
              }
            }
          }
          exp = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(mathJS.Expression, [op].concat(slice.call(params)), function(){});
          postfix.splice(startIdx, params.length + 1, exp);
          i = startIdx + 1;
        } else if (isOperand(token)) {
          postfix[i++] = new mathJS.Expression(parseFloat(token));
        } else {
          postfix[i++] = new mathJS.Variable(token);
        }
      }
      return postfix.first;
    };

    return ShuntingYard;

  })();

  mathJS.Operation = (function() {
    function Operation(name, precedence, associativity, commutative, func, inverse, setEquivalent) {
      if (associativity == null) {
        associativity = "left";
      }
      this.name = name;
      this.precedence = precedence;
      this.associativity = associativity;
      this.commutative = commutative;
      this.func = func;
      this.arity = func.length;
      this.inverse = inverse || null;
      this.setEquivalent = setEquivalent || null;
    }

    Operation.prototype["eval"] = function(args) {
      return this.func.apply(this, args);
    };

    Operation.prototype.invert = function() {
      if (this.inverse != null) {
        return this.inverse.apply(this, arguments);
      }
      return null;
    };

    return Operation;

  })();

  mathJS.Abstract = {
    Operations: {
      divide: function(x, y) {
        if (mathJS.Number.valueIsValid(x) && mathJS.Number.valueIsValid(y)) {
          x = new mathJS.Number(x);
          y = new mathJS.Number(y);
        }
        return x.divide(y);
      },
      minus: function(x, y) {
        if (mathJS.Number.valueIsValid(x) && mathJS.Number.valueIsValid(y)) {
          x = new mathJS.Number(x);
          y = new mathJS.Number(y);
        }
        return x.minus(y);
      },
      plus: function(x, y) {
        if (mathJS.Number.valueIsValid(x) && mathJS.Number.valueIsValid(y)) {
          x = new mathJS.Number(x);
          y = new mathJS.Number(y);
        }
        return x.plus(y);
      },
      times: function(x, y) {
        if (mathJS.Number.valueIsValid(x) && mathJS.Number.valueIsValid(y)) {
          x = new mathJS.Number(x);
          y = new mathJS.Number(y);
        }
        return x.times(y);
      },
      negate: function(x) {
        if (mathJS.Number.valueIsValid(x)) {
          x = new mathJS.Number(x);
        }
        return x.negate();
      },
      unaryPlus: function(x) {
        if (mathJS.Number.valueIsValid(x)) {
          x = new mathJS.Number(x);
        }
        return x.clone();
      },
      and: function(x, y) {
        return x.and(y);
      },
      or: function(x, y) {
        return x.or(y);
      },
      not: function(x) {
        return x.not();
      },
      nand: function(x, y) {
        return x.nand(y);
      },
      nor: function(x, y) {
        return x.nor(y);
      },
      xor: function(x, y) {
        return x.xor(y);
      },
      equals: function(x, y) {
        return x.equals(y);
      }
    }
  };


  /*
  PRECEDENCE (top to bottom):
  (...)
  factorial
  unary +/-
  exponents, roots
  multiplication, division
  addition, subtraction
   */

  cached = {
    division: new mathJS.Operation("divide", 1, "left", false, mathJS.pow, mathJS.root),
    addition: new mathJS.Operation("plus", 1, "left", true, mathJS.Abstract.Operations.plus, mathJS.Abstract.Operations.minus),
    subtraction: new mathJS.Operation("plus", 1, "left", false, mathJS.Abstract.Operations.minus, mathJS.Abstract.Operations.plus),
    multiplication: new mathJS.Operation("times", 1, "left", true, mathJS.Abstract.Operations.times, mathJS.Abstract.Operations.divide),
    exponentiation: new mathJS.Operation("pow", 1, "right", false, mathJS.pow, mathJS.root),
    factorial: new mathJS.Operation("factorial", 10, "right", false, mathJS.factorial, mathJS.factorialInverse),
    negate: new mathJS.Operation("negate", 11, "none", false, mathJS.Abstract.Operations.negate, mathJS.Abstract.Operations.negate),
    unaryPlus: new mathJS.Operation("unaryPlus", 11, "none", false, mathJS.Abstract.Operations.unaryPlus, mathJS.Abstract.Operations.unaryPlus),
    and: new mathJS.Operation("and", 1, "left", true, mathJS.Abstract.Operations.and, null, "intersection"),
    or: new mathJS.Operation("or", 1, "left", true, mathJS.Abstract.Operations.or, null, "union"),
    not: new mathJS.Operation("not", 5, "none", false, mathJS.Abstract.Operations.not, mathJS.Abstract.Operations.not, "complement"),
    nand: new mathJS.Operation("nand", 1, "left", true, mathJS.Abstract.Operations.nand, null),
    nor: new mathJS.Operation("nor", 1, "left", true, mathJS.Abstract.Operations.nor, null),
    xor: new mathJS.Operation("xor", 1, "left", true, mathJS.Abstract.Operations.xor, null),
    equals: new mathJS.Operation("equals", 1, "left", true, mathJS.Abstract.Operations.equals, null, "intersection")
  };

  mathJS.Operations = {
    "+": cached.addition,
    "plus": cached.addition,
    "-": cached.subtraction,
    "minus": cached.subtraction,
    "*": cached.multiplication,
    "times": cached.multiplication,
    "/": cached.division,
    ":": cached.division,
    "divide": cached.division,
    "^": cached.exponentiation,
    "pow": cached.exponentiation,
    "!": cached.factorial,
    "negate": cached.negate,
    "-u": cached.negate,
    "u-": cached.negate,
    "unaryMinus": cached.negate,
    "neutralMinus": cached.negate,
    "+u": cached.unaryPlus,
    "u+": cached.unaryPlus,
    "unaryPlus": cached.unaryPlus,
    "neutralPlus": cached.unaryPlus,
    "and": cached.and,
    "or": cached.or,
    "not": cached.not,
    "nand": cached.nand,
    "nor": cached.nor,
    "xor": cached.xor,
    "equals": cached.equals,
    "=": cached.equals,
    "xnor": cached.equals
  };


  /**
  * Tree structure of expressions. It consists of 2 expression and 1 operation.
  * @class Expression
  * @constructor
  * @param operation {Operation|String}
  * @param expressions... {Expression}
  *
   */

  mathJS.Expression = (function() {
    var CLASS;

    CLASS = Expression;

    Expression.fromString = function(str) {
      return new mathJS.Expression();
    };

    Expression.parse = Expression.fromString;

    Expression.parser = new mathJS.Algorithms.ShuntingYard({
      "!": {
        precedence: 5,
        associativity: "right"
      },
      "^": {
        precedence: 4,
        associativity: "right"
      },
      "*": {
        precedence: 3,
        associativity: "left"
      },
      "/": {
        precedence: 3,
        associativity: "left"
      },
      "+": {
        precedence: 2,
        associativity: "left"
      },
      "-": {
        precedence: 2,
        associativity: "left"
      }
    });

    Expression["new"] = function() {
      var expressions, operation;
      operation = arguments[0], expressions = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return new CLASS(operation, expressions);
    };

    function Expression() {
      var expressions, operation;
      operation = arguments[0], expressions = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (typeof operation === "string") {
        if (mathJS.Operations[operation] != null) {
          operation = mathJS.Operations[operation];
        } else {
          throw new mathJS.Errors.InvalidParametersError("Invalid operation string given: \"" + operation + "\".");
        }
      }
      if (expressions.first instanceof Array) {
        expressions = expressions.first;
      }
      if (expressions.length === 0) {
        if (mathJS.Number.valueIsValid(operation)) {
          this.operation = null;
          this.expressions = [new mathJS.Number(operation)];
        } else {
          if (operation instanceof mathJS.Variable) {
            this.operation = null;
            this.expressions = [operation];
          } else {
            this.operation = null;
            this.expressions = [new mathJS.Variable(operation)];
          }
        }
      } else if (operation.arity === expressions.length) {
        this.operation = operation;
        this.expressions = expressions;
      } else {
        throw new mathJS.Errors.InvalidArityError("Invalid number of parameters (" + expressions.length + ") for Operation \"" + operation.name + "\". Expected number of parameters is " + operation.arity + ".");
      }
    }


    /**
    * This method tests for the equality of structure. So 2*3x does not equal 6x!
    * For that see mathEquals().
    * @method equals
    *
     */

    Expression.prototype.equals = function(expression) {
      var doneExpressions, e1, e2, exp, i, j, l, len1, len2, len3, o, q, ref, ref1, ref2, res, x;
      if (this.expressions.length !== expression.expressions.length) {
        return false;
      }
      if (this.operation == null) {
        return (expression.operation == null) && expression.expressions.first.equals(this.expressions.first);
      }
      if (this.operation.commutative === true) {
        doneExpressions = [];
        ref = this.expressions;
        for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
          exp = ref[i];
          res = false;
          ref1 = expression.expressions;
          for (j = o = 0, len2 = ref1.length; o < len2; j = ++o) {
            x = ref1[j];
            if (!(indexOf.call(doneExpressions, j) < 0 && x.equals(exp))) {
              continue;
            }
            doneExpressions.push(j);
            res = true;
            break;
          }
          if (!res) {
            return false;
          }
        }
        return true;
      } else {
        ref2 = this.expressions;
        for (i = q = 0, len3 = ref2.length; q < len3; i = ++q) {
          e1 = ref2[i];
          e2 = expression.expressions[i];
          if (!e1.equals(e2)) {
            return false;
          }
        }
        return true;
      }
    };


    /**
    * This method tests for the logical/mathematical equality of 2 expressions.
    *
     */

    Expression.prototype.mathEquals = function(expression) {
      return this.simplify().equals(expression.simplify());
    };


    /**
    * @method eval
    * @param values {Object}
    * An object of the form {varKey: varVal}.
    * @returns The value of the expression (specified by the values).
    *
     */

    Expression.prototype["eval"] = function(values) {
      var args, expression, k, l, len1, ref, v, value;
      for (k in values) {
        v = values[k];
        if (mathJS.isPrimitive(v) && mathJS.Number.valueIsValid(v)) {
          values[k] = new mathJS.Number(v);
        }
      }
      if (this.operation == null) {
        return this.expressions.first["eval"](values);
      }
      args = [];
      ref = this.expressions;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        expression = ref[l];
        value = expression["eval"](values);
        if (value instanceof mathJS.Variable) {
          return this;
        }
        args.push(value);
      }
      return this.operation["eval"](args);
    };

    Expression.prototype.simplify = function() {
      var evaluated;
      evaluated = this["eval"]();
      return this;
    };

    Expression.prototype.getVariables = function() {
      var expression, l, len1, ref, res, val;
      if (this.operation == null) {
        if ((val = this.expressions.first) instanceof mathJS.Variable) {
          return [val];
        }
        return [];
      }
      res = [];
      ref = this.expressions;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        expression = ref[l];
        res = res.concat(expression.getVariables());
      }
      return res;
    };

    Expression.prototype._getSet = function() {
      var expression, l, len1, ref, res;
      if (this.operation == null) {
        return this.expressions.first._getSet();
      }
      res = null;
      ref = this.expressions;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        expression = ref[l];
        if (res != null) {
          res = res[this.operation.setEquivalent](expression._getSet());
        } else {
          res = expression._getSet();
        }
      }
      return res || new mathJS.Set();
    };


    /**
    * Get the "range" of the expression (the set of all possible results).
    * @method getSet
    *
     */

    Expression.prototype.getSet = function() {
      return this["eval"]()._getSet();
    };

    Expression.prototype.evaluatesTo = Expression.prototype.getSet;

    if (DEBUG) {
      Expression.test = function() {
        var e1, e2, e4, str;
        e1 = new CLASS(5);
        e2 = new CLASS(new mathJS.Variable("x", mathJS.Number));
        e4 = new CLASS("+", e1, e2);
        console.log(e4.getVariables());
        str = "(5x - 3)  ^ 2 * 2 / (4y + 3!)";
        return "test done";
      };
    }

    return Expression;

  })();


  /**
  * @class Variable
  * @constructor
  * @param {String} name
  * This is name name of the variable (mathematically)
  * @param {mathJS.Set} type
  *
   */

  mathJS.Variable = (function(superClass) {
    extend(Variable, superClass);

    function Variable(name, elementOf) {
      if (elementOf == null) {
        elementOf = mathJS.Domains.N;
      }
      this.name = name;
      if (elementOf.getSet != null) {
        this.elementOf = elementOf.getSet();
      } else {
        this.elementOf = elementOf;
      }
    }

    Variable.prototype._getSet = function() {
      return this.elementOf;
    };

    Variable.prototype.equals = function(variable) {
      return this.name === variable.name && this.elementOf.equals(variable.elementOf);
    };

    Variable.prototype.plus = function(n) {
      return new mathJS.Expression("+", this, n);
    };

    Variable.prototype.minus = function(n) {
      return new mathJS.Expression("-", this, n);
    };

    Variable.prototype.times = function(n) {
      return new mathJS.Expression("*", this, n);
    };

    Variable.prototype.divide = function(n) {
      return new mathJS.Expression("/", this, n);
    };

    Variable.prototype["eval"] = function(values) {
      var val;
      if ((values != null) && ((val = values[this.name]) != null)) {
        if (this.elementOf.contains(val)) {
          return val;
        }
        console.warn("Given value \"" + val + "\" is not in the set \"" + this.elementOf.name + "\".");
      }
      return this;
    };

    return Variable;

  })(mathJS.Expression);

  mathJS.Equation = (function() {
    function Equation(left, right) {
      this.left = left;
      this.right = right;
    }

    Equation.prototype.solve = function(variable) {
      var left, right, solutions, v, variables;
      left = this.left.simplify();
      right = this.right.simplify();
      solutions = new mathJS.Set();
      if (!(variable instanceof mathJS.Variable)) {
        variables = left.getVariables().concat(right.getVariables());
        variable = ((function() {
          var l, len1, results;
          results = [];
          for (l = 0, len1 = variables.length; l < len1; l++) {
            v = variables[l];
            if (v.name === variable) {
              results.push(v);
            }
          }
          return results;
        })()).first;
      }
      return solutions;
    };

    Equation.prototype["eval"] = function(values) {
      return this.left["eval"](values).equals(this.right["eval"](values));
    };

    Equation.prototype.simplify = function() {
      this.left = this.left.simplify();
      this.right = this.right.simplify();
      return this;
    };

    return Equation;

  })();

  _mathJS.AbstractSet = (function(superClass) {
    extend(AbstractSet, superClass);

    function AbstractSet() {
      return AbstractSet.__super__.constructor.apply(this, arguments);
    }

    AbstractSet["implements"](_mathJS.Orderable, _mathJS.Poolable, _mathJS.Parseable);

    AbstractSet.fromString = function(str) {};

    AbstractSet.parse = function() {
      return this.fromString.apply(this, arguments);
    };

    AbstractSet.prototype.cartesianProduct = function(set) {};

    AbstractSet.prototype.clone = function() {};

    AbstractSet.prototype.contains = function(elem) {};

    AbstractSet.prototype.equals = function(set) {};

    AbstractSet.prototype.getElements = function() {};

    AbstractSet.prototype.infimum = function() {};

    AbstractSet.prototype.intersection = function(set) {};

    AbstractSet.prototype.isSubsetOf = function(set) {};

    AbstractSet.prototype.min = function() {};

    AbstractSet.prototype.max = function() {};

    AbstractSet.prototype.size = function() {
      return Infinity;
    };

    AbstractSet.prototype.supremum = function() {};

    AbstractSet.prototype.union = function(set) {};

    AbstractSet.prototype.intersection = function(set) {};

    AbstractSet.prototype.without = function(set) {};

    AbstractSet.prototype.complement = function(universe) {
      return universe.minus(this);
    };

    AbstractSet.prototype.disjoint = function(set) {
      return this.intersection(set).size() === 0;
    };

    AbstractSet.prototype.intersects = function(set) {
      return !this.disjoint(set);
    };

    AbstractSet.prototype.isEmpty = function() {
      return this.size() === 0;
    };

    AbstractSet.prototype.isSupersetOf = function(set) {
      return set.isSubsetOf(this);
    };

    AbstractSet.prototype.pow = function(exponent) {
      var i, l, ref, sets;
      sets = [];
      for (i = l = 0, ref = exponent; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        sets.push(this);
      }
      return this.cartesianProduct.apply(this, sets);
    };

    AbstractSet._makeAliases = function() {
      var alias, aliases, aliasesData, l, len1, orig;
      aliasesData = {
        size: ["cardinality"],
        without: ["difference", "except", "minus"],
        contains: ["has"],
        intersection: ["intersect"],
        isSubsetOf: ["subsetOf"],
        isSupersetOf: ["supersetOf"],
        cartesianProduct: ["times"]
      };
      for (orig in aliasesData) {
        aliases = aliasesData[orig];
        for (l = 0, len1 = aliases.length; l < len1; l++) {
          alias = aliases[l];
          this.prototype[alias] = this.prototype[orig];
        }
      }
      return this;
    };

    AbstractSet._makeAliases();

    return AbstractSet;

  })(_mathJS.Object);


  /**
  * @class Set
  * @constructor
  * @param {mixed} specifications
  * To create an empty set pass no parameters.
  * To create a discrete set list the elements. Those elements must implement the comparable interface and must not be arrays. Non-comparable elements will be ignored unless they are primitives.
  * To create a set from set-builder notation pass the parameters must have the following types:
  * mathJS.Expression|mathJS.Tuple|mathJS.Number, mathJS.Predicate
   * TODO: package all those types (expression-like) into 1 prototype (Variable already is)
  *
   */

  mathJS.Set = (function(superClass) {
    var newFromConditional, newFromDiscrete;

    extend(Set, superClass);


    /**
    * Optionally the left and right configuration can be passed directly (each with an open- and value-property) or the Interval can be parsed from String (like "(2, 6 ]").
    * @static
    * @method createInterval
    * @param leftOpen {Boolean}
    * @param leftValue {Number|mathJS.Number}
    * @param rightValue {Number|mathJS.Number}
    * @param rightOpen {Boolean}
    *
     */

    Set.createInterval = function() {
      var expression, fourth, left, parameters, predicate, right, second, str;
      parameters = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (typeof (str = parameters.first) === "string") {
        str = str.replace(/\s+/g, "").split(",");
        left = {
          open: str.first[0] === "(",
          value: new mathJS.Number(parseInt(str.first.slice(1), 10))
        };
        right = {
          open: str.second.last === ")",
          value: new mathJS.Number(parseInt(str.second.slice(0, -1), 10))
        };
      } else {
        second = parameters.second;
        fourth = parameters.fourth;
        left = {
          open: parameters.first,
          value: (second instanceof mathJS.Number ? second : new mathJS.Number(second))
        };
        right = {
          open: parameters.third,
          value: (fourth instanceof mathJS.Number ? fourth : new mathJS.Number(fourth))
        };
      }
      expression = new mathJS.Variable("x", mathJS.Domains.N);
      predicate = null;
      return new mathJS.Set(expression, predicate);
    };

    function Set() {
      var parameters;
      parameters = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (parameters.length === 0) {
        this.discreteSet = new _mathJS.DiscreteSet();
        this.conditionalSet = new _mathJS.ConditionalSet();
      } else if (parameters.first instanceof _mathJS.DiscreteSet && parameters.second instanceof _mathJS.ConditionalSet) {
        this.discreteSet = parameters.first;
        this.conditionalSet = parameters.second;
      } else if (parameters.first instanceof mathJS.Expression && parameters.second instanceof mathJS.Expression) {
        console.log("set builder");
        this.discreteSet = new _mathJS.DiscreteSet();
        this.conditionalSet = new _mathJS.ConditionalSet(parameters.first, parameters.slice(1));
      } else {
        if (parameters.first instanceof Array) {
          parameters = parameters.first;
        }
        console.log("params:", parameters);
        this.discreteSet = new _mathJS.DiscreteSet(parameters);
        this.conditionalSet = new _mathJS.ConditionalSet();
      }
    }

    newFromDiscrete = function(set) {
      return new mathJS.Set(set.getElements());
    };

    newFromConditional = function(set) {
      return new mathJS.Set(set.expression, set.domains, set.predicate);
    };

    Set.prototype.getElements = function(n, sorted) {
      var res;
      if (n == null) {
        n = mathJS.config.set.defaultNumberOfElements;
      }
      if (sorted == null) {
        sorted = false;
      }
      res = this.discreteSet.elems.concat(this.conditionalSet.getElements(n, sorted));
      if (sorted !== true) {
        return res;
      }
      return res.sort(mathJS.sortFunction);
    };

    Set.prototype.size = function() {
      return this.discreteSet.size() + this.conditionalSet.size();
    };

    Set.prototype.clone = function() {
      return newFromDiscrete(this.discreteSet).union(newFromConditional(this.conditionalSet));
    };

    Set.prototype.equals = function(set) {
      if (set.size() !== this.size()) {
        return false;
      }
      return set.discreteSet.equals(this.discreteSet) && set.conditionalSet.equals(this.conditionalSet);
    };

    Set.prototype.getSet = function() {
      return this;
    };

    Set.prototype.isSubsetOf = function(set) {
      return this.conditionalSet.isSubsetOf(set) || this.discreteSet.isSubsetOf(set);
    };

    Set.prototype.isSupersetOf = function(set) {
      return this.conditionalSet.isSupersetOf(set) || this.discreteSet.isSupersetOf(set);
    };

    Set.prototype.contains = function(elem) {
      return this.conditionalSet.contains(this.conditionalSet) || this.discreteSet.contains(this.discreteSet);
    };

    Set.prototype.union = function(set) {
      if (set.isDomain) {
        return set.union(this);
      }
      return new mathJS.Set(this.discreteSet.union(set.discreteSet), this.conditionalSet.union(set.conditionalSet));
    };

    Set.prototype.intersection = function(set) {
      if (set.isDomain) {
        return set.intersection(this);
      }
      return new mathJS.Set(this.discreteSet.intersection(set.discreteSet), this.conditionalSet.intersection(set.conditionalSet));
    };

    Set.prototype.complement = function() {
      if (this.universe != null) {
        return asdf;
      }
      return new mathJS.EmptySet();
    };

    Set.prototype.without = function(set) {};

    Set.prototype.cartesianProduct = function(set) {};

    Set.prototype.min = function() {
      return mathJS.min(this.discreteSet.min().concat(this.conditionalSet.min()));
    };

    Set.prototype.max = function() {
      return mathJS.max(this.discreteSet.max().concat(this.conditionalSet.max()));
    };

    Set.prototype.infimum = function() {};

    Set.prototype.supremum = function() {};

    return Set;

  })(_mathJS.AbstractSet);


  /**
  * This class is a Setof explicitely listed elements (with no needed logic).
  * @class DiscreteSet
  * @constructor
  * @param {Function|Class} type
  * @param {Set} universe
  * Optional. If given, the created Set will be interpreted as a sub set of the universe.
  * @param {mixed} elems...
  * Optional. This and the following parameters serve as elements for the new Set. They will be in the new Set immediately.
  * @extends Set
  *
   */

  _mathJS.DiscreteSet = (function(superClass) {
    extend(DiscreteSet, superClass);

    function DiscreteSet() {
      var elem, elems, l, len1;
      elems = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (elems.first instanceof Array) {
        elems = elems.first;
      }
      this.elems = [];
      for (l = 0, len1 = elems.length; l < len1; l++) {
        elem = elems[l];
        if (!this.contains(elem)) {
          if (!mathJS.isNum(elem)) {
            this.elems.push(elem);
          } else {
            this.elems.push(new mathJS.Number(elem));
          }
        }
      }
    }

    DiscreteSet.prototype.cartesianProduct = function(set) {
      var e, elements, l, len1, len2, o, ref, ref1, x;
      elements = [];
      ref = this.elems;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        e = ref[l];
        ref1 = set.elems;
        for (o = 0, len2 = ref1.length; o < len2; o++) {
          x = ref1[o];
          elements.push(new mathJS.Tuple(e, x));
        }
      }
      return new _mathJS.DiscreteSet(elements);
    };

    DiscreteSet.prototype.clone = function() {
      return new _mathJS.DiscreteSet(this.elems);
    };

    DiscreteSet.prototype.contains = function(elem) {
      var e, l, len1, ref;
      ref = this.elems;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        e = ref[l];
        if (elem.equals(e)) {
          return true;
        }
      }
      return false;
    };

    DiscreteSet.prototype.equals = function(set) {
      var e, l, len1, len2, o, ref, ref1;
      ref = this.elems;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        e = ref[l];
        if (!set.contains(e)) {
          return false;
        }
      }
      ref1 = set.elems;
      for (o = 0, len2 = ref1.length; o < len2; o++) {
        e = ref1[o];
        if (!this.contains(e)) {
          return false;
        }
      }
      return true;
    };


    /**
    * Get the elements of the set.
    * @method getElements
    * @param sorted {Boolean}
    * Optional. If set to `true` returns the elements in ascending order.
    *
     */

    DiscreteSet.prototype.getElements = function(sorted) {
      if (sorted !== true) {
        return this.elems.clone();
      }
      return this.elems.clone().sort(mathJS.sortFunction);
    };

    DiscreteSet.prototype.intersection = function(set) {
      var elems, l, len1, len2, o, ref, ref1, x, y;
      elems = [];
      ref = this.elems;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        x = ref[l];
        ref1 = set.elems;
        for (o = 0, len2 = ref1.length; o < len2; o++) {
          y = ref1[o];
          if (x.equals(y)) {
            elems.push(x);
          }
        }
      }
      return new _mathJS.DiscreteSet(elems);
    };

    DiscreteSet.prototype.isSubsetOf = function(set) {
      var e, l, len1, ref;
      ref = this.elems;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        e = ref[l];
        if (!set.contains(e)) {
          return false;
        }
      }
      return true;
    };

    DiscreteSet.prototype.size = function() {
      return this.elems.length;
    };

    DiscreteSet.prototype.union = function(set) {
      return new _mathJS.DiscreteSet(set.elems.concat(this.elems));
    };

    DiscreteSet.prototype.without = function(set) {
      var elem;
      return (function() {
        var l, len1, ref, results;
        ref = this.elems;
        results = [];
        for (l = 0, len1 = ref.length; l < len1; l++) {
          elem = ref[l];
          if (!set.contains(elem)) {
            results.push(elem);
          }
        }
        return results;
      }).call(this);
    };

    DiscreteSet.prototype.min = function() {
      return mathJS.min(this.elems);
    };

    DiscreteSet.prototype.max = function() {
      return mathJS.max(this.elems);
    };

    DiscreteSet.prototype.infimum = function() {};

    DiscreteSet.prototype.supremum = function() {};

    DiscreteSet._makeAliases();

    return DiscreteSet;

  })(mathJS.Set);

  _mathJS.ConditionalSet = (function(superClass) {
    var CLASS;

    extend(ConditionalSet, superClass);

    CLASS = ConditionalSet;


    /*
    {2x^2 | x in R and 0 <= x < 20 and x = x^2} ==> {0, 1}
    x in R and 0 <= x < 20 and x = x^2 <=> R intersect [0, 20) intersect {0,1} (where 0 and 1 have to be part of the previous set)
    do the following:
    1. map domains to domains
    2. map unequations to intervals
    3. map equations to (discrete?!) sets
    4. create intersection of all!
    
    simplifications:
    1.  domains intersect interval = interval (because in this notation the domain is the superset)
        so it wouldnt make sense to say: x in N and x in [0, 10] and expect the set to be infinite!!
        the order does not matter (otherwise (x in [0, 10] and x in N) would be infinite!!)
    2.  when trying to get equation solutions numerically (should this ever happen??) look for interval first to get boundaries
     */

    function ConditionalSet(expression, predicate) {
      if (arguments.length === 0) {
        this.generator = null;
      } else if (expression instanceof mathJS.Generator) {
        this.generator = expression;
      } else {
        if (predicate instanceof mathJS.Expression) {
          predicate = predicate.getSet();
        }
        this.generator = new mathJS.Generator(new mathJS.Function("f", expression, predicate, expression.getSet()), predicate.min(), predicate.max());
      }
    }

    ConditionalSet.prototype.cartesianProduct = function() {
      var generators, ref, set, sets;
      sets = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      generators = [this.generator].concat((function() {
        var l, len1, results;
        results = [];
        for (l = 0, len1 = sets.length; l < len1; l++) {
          set = sets[l];
          results.push(set.generator);
        }
        return results;
      })());
      return new _mathJS.ConditionalSet((ref = mathJS.Generator).product.apply(ref, generators));
    };

    ConditionalSet.prototype.clone = function() {
      return new CLASS();
    };

    ConditionalSet.prototype.contains = function(elem) {
      var ref;
      if (mathJS.isComparable(elem)) {
        if (((ref = this.condition) != null ? ref.check(elem) : void 0) === true) {
          return true;
        }
      }
      return false;
    };

    ConditionalSet.prototype.equals = function(set) {
      if (set instanceof CLASS) {
        return this.generator.f.equals(set.generator.f);
      }
      return set.discreteSet.isEmpty() && this.generator.f.equals(set.conditionSet.generator.f);
    };

    ConditionalSet.prototype.getElements = function(n, sorted) {
      var res;
      res = [];
      return res;
    };

    ConditionalSet.prototype.intersection = function(set) {};

    ConditionalSet.prototype.isSubsetOf = function(set) {};

    ConditionalSet.prototype.isSupersetOf = function(set) {};

    ConditionalSet.prototype.size = function() {
      return this.generator.f.range.size();
    };

    ConditionalSet.prototype.union = function(set) {};

    ConditionalSet.prototype.without = function(set) {};

    ConditionalSet._makeAliases();

    if (DEBUG) {
      ConditionalSet.test = function() {
        var e1, e2, e3, p1, p2, p3;
        e1 = new mathJS.Expression(5);
        e2 = new mathJS.Expression(new mathJS.Variable("x", mathJS.Number));
        e3 = new mathJS.Expression("+", e1, e2);
        p1 = new mathJS.Expression(new mathJS.Variable("x", mathJS.Number));
        p2 = new mathJS.Expression(4);
        p3 = new mathJS.Expression("=", p1, p2);
        console.log(p3["eval"]({
          x: 4
        }));
        console.log(p3.getSet());
        console.log(AAA);
        return "done";
      };
    }

    return ConditionalSet;

  })(mathJS.Set);

  mathJS.Tuple = (function() {
    function Tuple() {
      var elem, elems, l, len1, temp;
      elems = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (elems.first instanceof Array) {
        elems = elems.first;
      }
      temp = [];
      for (l = 0, len1 = elems.length; l < len1; l++) {
        elem = elems[l];
        if (!mathJS.isNum(elem)) {
          temp.push(elem);
        } else {
          temp.push(new mathJS.Number(elem));
        }
      }
      this.elems = temp;
      this._size = temp.length;
    }

    Object.defineProperties(Tuple.prototype, {
      first: {
        get: function() {
          return this.at(0);
        },
        set: function() {
          return this;
        }
      },
      length: {
        get: function() {
          return this._size;
        },
        set: function() {
          return this;
        }
      }
    });

    Tuple.prototype.add = function() {
      var elems;
      elems = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return new mathJS.Tuple(this.elems.concat(elems));
    };

    Tuple.prototype.at = function(idx) {
      return this.elems[idx];
    };

    Tuple.prototype.clone = function() {
      return new mathJS.Tuple(this.elems);
    };

    Tuple.prototype.contains = function(elem) {
      var e, l, len1, ref;
      ref = this.elems;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        e = ref[l];
        if (e.equals(elem)) {
          return true;
        }
      }
      return false;
    };

    Tuple.prototype.equals = function(tuple) {
      var elem, elements, idx, l, len1, ref;
      if (this._size !== tuple._size) {
        return false;
      }
      elements = tuple.elems;
      ref = this.elems;
      for (idx = l = 0, len1 = ref.length; l < len1; idx = ++l) {
        elem = ref[idx];
        if (!elem.equals(elements[idx])) {
          return false;
        }
      }
      return true;
    };


    /**
    * Evaluates the tuple.
    * @param values {Array}
    * # TODO: also enables hash of vars
    * A value for each tuple element.
    *
     */

    Tuple.prototype["eval"] = function(values) {
      var elem, elems, i;
      elems = (function() {
        var l, len1, ref, results;
        ref = this.elems;
        results = [];
        for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
          elem = ref[i];
          results.push(elem["eval"](values[i]));
        }
        return results;
      }).call(this);
      return new mathJS.Tuple(elems);
    };


    /**
    * Get the elements of the Tuple.
    * @method getElements
    *
     */

    Tuple.prototype.getElements = function() {
      return this.elems.clone();
    };

    Tuple.prototype.insert = function() {
      var elem, elements, elems, i, idx, l, len1, ref;
      idx = arguments[0], elems = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      elements = [];
      ref = this.elems;
      for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
        elem = ref[i];
        if (i === idx) {
          elements = elements.concat(elems);
        }
        elements.push(elem);
      }
      return new mathJS.Tuple(elements);
    };

    Tuple.prototype.isEmpty = function() {
      return this._size() === 0;
    };


    /**
    * Removes the first occurences of the given elements.
    *
     */

    Tuple.prototype.remove = function() {
      var e, elem, elements, elems, i, l, len1, len2, o;
      elems = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      elements = this.elems.clone();
      for (l = 0, len1 = elems.length; l < len1; l++) {
        e = elems[l];
        for (i = o = 0, len2 = elements.length; o < len2; i = ++o) {
          elem = elements[i];
          if (!(elem.equals(e))) {
            continue;
          }
          elements.splice(i, 1);
          break;
        }
      }
      return new mathJS.Tuple(elements);
    };

    Tuple.prototype.removeAt = function(idx, n) {
      var elem, elems, i, l, len1, ref;
      if (n == null) {
        n = 1;
      }
      elems = [];
      ref = this.elems;
      for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
        elem = ref[i];
        if (i < idx || i >= idx + n) {
          elems.push(elem);
        }
      }
      return new mathJS.Tuple(elems);
    };

    Tuple.prototype.size = function() {
      return this._size;
    };

    Tuple.prototype.slice = function(startIdx, endIdx) {
      if (endIdx == null) {
        endIdx = this._size;
      }
      return new mathJS.Tuple(this.elems.slice(startIdx, endIdx));
    };

    Tuple.prototype.cardinality = Tuple.prototype.size;

    Tuple.prototype.extendBy = Tuple.prototype.add;

    Tuple.prototype.get = Tuple.prototype.at;

    Tuple.prototype.has = Tuple.prototype.contains;

    Tuple.prototype.addAt = Tuple.prototype.insert;

    Tuple.prototype.insertAt = Tuple.prototype.insert;

    Tuple.prototype.reduceBy = Tuple.prototype.remove;

    return Tuple;

  })();

  mathJS.Function = (function(superClass) {
    extend(Function, superClass);

    function Function(name, expression, domain, range) {
      this.name = name;
      this.expression = expression;
      if (domain instanceof mathJS.Set) {
        this.domain = domain;
      } else {
        this.domain = new mathJS.Set(expression.getVariables());
      }
      if (range instanceof mathJS.Set) {
        this.range = range;
      } else {
        this.range = expression.getSet();
      }
      this._cache = {};
      this.caching = true;
      Function.__super__.constructor.call(this);
    }


    /**
    * Empty the cache or reset to given cache.
    * @method clearCache
    * @param cache {Object}
    * @return mathJS.Function
    * @chainable
    *
     */

    Function.prototype.clearCache = function(cache) {
      if (cache == null) {
        this._cache = {};
      } else {
        this._cache = cache;
      }
      return this;
    };


    /**
    * Evaluate the function for given values.
    * @method get
    * @param values {Array|Object}
    * If an array the first value will be associated with the first variable name. Otherwise an object like {x: 42} is expected.
    * @return
    *
     */

    Function.prototype["eval"] = function() {
      var i, l, len1, tmp, val, value, values, varName;
      values = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      tmp = {};
      if (values instanceof Array) {
        for (i = l = 0, len1 = values.length; l < len1; i = ++l) {
          value = values[i];
          tmp[this.variableNames[i]] = value;
        }
        values = tmp;
      }
      for (varName in values) {
        val = values[varName];
        if (!domain.contains(val)) {
          return null;
        }
      }
      return this.expression["eval"](values);
    };

    Function.prototype.at = Function["eval"];

    Function.prototype.get = Function["eval"];

    return Function;

  })(mathJS.Set);

  _mathJS.AbstractGenerator = (function(superClass) {
    extend(AbstractGenerator, superClass);

    function AbstractGenerator(f, minX, maxX, stepSize, maxIndex, tuple) {
      if (minX == null) {
        minX = 0;
      }
      if (maxX == null) {
        maxX = Infinity;
      }
      if (stepSize == null) {
        stepSize = mathJS.config.number.real.distance;
      }
      if (maxIndex == null) {
        maxIndex = mathJS.config.generator.maxIndex;
      }
      this.f = f;
      this.inverseF = f.getInverse();
      this.minX = minX;
      this.maxX = maxX;
      this.stepSize = stepSize;
      this.maxIndex = maxIndex;
      this.tuple = tuple;
      this.x = minX;
      this.overflowed = false;
      this.index = 0;
    }

    Object.defineProperties(AbstractGenerator.prototype, {
      "function": {
        get: function() {
          return this.f;
        },
        set: function(f) {
          this.f = f;
          this.inverseF = f.getInverse();
          return this;
        }
      }
    });

    AbstractGenerator.product = function() {
      var generators;
      generators = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    };

    AbstractGenerator.or = function(gen1, gen2) {};

    AbstractGenerator.and = function(gen1, gen2) {};


    /**
    * Indicates whether the set the generator creates contains the given value or not.
    * @method generates
    *
     */

    AbstractGenerator.prototype.generates = function(y) {
      if (this.f.range.contains(y)) {
        if (this.inverseF != null) {
          return this.inverseF["eval"](y);
        }
        return;
      }
      return false;
    };

    AbstractGenerator.prototype["eval"] = function(n) {
      if (this.tuple != null) {
        return this.tuple["eval"](n);
      }
      if (this.f["eval"] != null) {
        this.f["eval"](n);
      }
      return this.f.call(this, n);
    };

    AbstractGenerator.prototype.hasNext = function() {
      var g, i, l, len1, ref;
      if (this.tuple != null) {
        ref = this.tuple.elems;
        for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
          g = ref[i];
          if (g.hasNext()) {
            return true;
          }
        }
        return false;
      }
      return !this.overflowed && this.x < this.maxX && this.index < this.maxIndex;
    };

    AbstractGenerator.prototype._incX = function() {
      this.index++;
      this.x = this.minX + this.index * this.stepSize;
      if (this.x > this.maxX) {
        this.x = this.minX;
        this.index = 0;
        this.overflowed = true;
      }
      return this.x;
    };

    AbstractGenerator.prototype.next = function() {
      var g, generator, i, maxI, res;
      if (this.tuple != null) {
        res = this["eval"]((function() {
          var l, len1, ref, results;
          ref = this.tuple.elems;
          results = [];
          for (l = 0, len1 = ref.length; l < len1; l++) {
            g = ref[l];
            results.push(g.x);
          }
          return results;
        }).call(this));

        /*
        0 0
        0 1
        1 0
        1 1
         */
        i = 0;
        maxI = this.tuple.length;
        generator = this.tuple.first;
        generator._incX();
        while (i < maxI && generator.overflowed) {
          generator.overflowed = false;
          generator = this.tuple.at(++i);
          if (generator != null) {
            generator._incX();
          }
        }
        return res;
      }
      res = this["eval"](this.x);
      this._incX();
      return res;
    };

    AbstractGenerator.prototype.reset = function() {
      this.x = this.minX;
      this.index = 0;
      return this;
    };

    if (DEBUG) {
      AbstractGenerator.test = function() {
        var g, g1, g2, res, tmp;
        g = new mathJS.Generator(function(x) {
          return 3 * x * x + 2 * x - 5;
        }, -10, 10, 0.2);
        res = [];
        while (g.hasNext()) {
          tmp = g.next();
          res.push(tmp);
        }
        tmp = g.next();
        res.push(tmp);
        console.log("simple test:", (res.length === ((g.maxX - g.minX) / g.stepSize + 1) ? "successful" : "failed"));
        g1 = new mathJS.Generator(function(x) {
          return x;
        }, 0, 5, 0.5);
        g2 = new mathJS.Generator(function(x) {
          return 2 * x;
        }, -2, 10, 2);
        g = mathJS.Generator.product(g1, g2);
        res = [];
        while (g.hasNext()) {
          tmp = g.next();
          res.push(tmp);
        }
        tmp = g.next();
        res.push(tmp);
        console.log("tuple test:", (res.length === ((g1.maxX - g1.minX) / g1.stepSize + 1) * ((g2.maxX - g2.minX) / g2.stepSize + 1) ? "successful" : "failed"));
        g = new mathJS.Generator(function(x) {
          return x;
        });
        while (g.hasNext()) {
          tmp = g.next();
        }
        tmp = g.next();
        return "done";
      };
    }

    return AbstractGenerator;

  })(_mathJS.Object);

  mathJS.DiscreteGenerator = (function(superClass) {
    extend(DiscreteGenerator, superClass);

    function DiscreteGenerator(f, minX, maxX, stepSize, maxIndex, tuple) {
      if (minX == null) {
        minX = 0;
      }
      if (maxX == null) {
        maxX = Infinity;
      }
      if (stepSize == null) {
        stepSize = mathJS.config.number.real.distance;
      }
      if (maxIndex == null) {
        maxIndex = mathJS.config.generator.maxIndex;
      }
      this.f = f;
      this.inverseF = f.getInverse();
      this.minX = minX;
      this.maxX = maxX;
      this.stepSize = stepSize;
      this.maxIndex = maxIndex;
      this.tuple = tuple;
      this.x = minX;
      this.overflowed = false;
      this.index = 0;
    }

    Object.defineProperties(DiscreteGenerator.prototype, {
      "function": {
        get: function() {
          return this.f;
        },
        set: function(f) {
          this.f = f;
          this.inverseF = f.getInverse();
          return this;
        }
      }
    });

    DiscreteGenerator.product = function() {
      var generators;
      generators = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return new mathJS.Generator(null, 0, Infinity, null, null, new mathJS.Tuple(generators));
    };

    DiscreteGenerator.or = function() {};

    DiscreteGenerator.and = function() {};


    /**
    * Indicates whether the set the generator creates contains the given value or not.
    * @method generates
    *
     */

    DiscreteGenerator.prototype.generates = function(y) {
      if (this.f.range.contains(y)) {
        if (this.inverseF != null) {
          return this.inverseF["eval"](y);
        }
        return;
      }
      return false;
    };

    DiscreteGenerator.prototype["eval"] = function(n) {
      if (this.tuple != null) {
        return this.tuple["eval"](n);
      }
      if (this.f["eval"] != null) {
        this.f["eval"](n);
      }
      return this.f.call(this, n);
    };

    DiscreteGenerator.prototype.hasNext = function() {
      var g, i, l, len1, ref;
      if (this.tuple != null) {
        ref = this.tuple.elems;
        for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
          g = ref[i];
          if (g.hasNext()) {
            return true;
          }
        }
        return false;
      }
      return !this.overflowed && this.x < this.maxX && this.index < this.maxIndex;
    };

    DiscreteGenerator.prototype._incX = function() {
      this.index++;
      this.x = this.minX + this.index * this.stepSize;
      if (this.x > this.maxX) {
        this.x = this.minX;
        this.index = 0;
        this.overflowed = true;
      }
      return this.x;
    };

    DiscreteGenerator.prototype.next = function() {
      var g, generator, i, maxI, res;
      if (this.tuple != null) {
        res = this["eval"]((function() {
          var l, len1, ref, results;
          ref = this.tuple.elems;
          results = [];
          for (l = 0, len1 = ref.length; l < len1; l++) {
            g = ref[l];
            results.push(g.x);
          }
          return results;
        }).call(this));

        /*
        0 0
        0 1
        1 0
        1 1
         */
        i = 0;
        maxI = this.tuple.length;
        generator = this.tuple.first;
        generator._incX();
        while (i < maxI && generator.overflowed) {
          generator.overflowed = false;
          generator = this.tuple.at(++i);
          if (generator != null) {
            generator._incX();
          }
        }
        return res;
      }
      res = this["eval"](this.x);
      this._incX();
      return res;
    };

    DiscreteGenerator.prototype.reset = function() {
      this.x = this.minX;
      this.index = 0;
      return this;
    };

    if (DEBUG) {
      DiscreteGenerator.test = function() {
        var g, g1, g2, res, tmp;
        g = new mathJS.Generator(function(x) {
          return 3 * x * x + 2 * x - 5;
        }, -10, 10, 0.2);
        res = [];
        while (g.hasNext()) {
          tmp = g.next();
          res.push(tmp);
        }
        tmp = g.next();
        res.push(tmp);
        console.log("simple test:", (res.length === ((g.maxX - g.minX) / g.stepSize + 1) ? "successful" : "failed"));
        g1 = new mathJS.Generator(function(x) {
          return x;
        }, 0, 5, 0.5);
        g2 = new mathJS.Generator(function(x) {
          return 2 * x;
        }, -2, 10, 2);
        g = mathJS.Generator.product(g1, g2);
        res = [];
        while (g.hasNext()) {
          tmp = g.next();
          res.push(tmp);
        }
        tmp = g.next();
        res.push(tmp);
        console.log("tuple test:", (res.length === ((g1.maxX - g1.minX) / g1.stepSize + 1) * ((g2.maxX - g2.minX) / g2.stepSize + 1) ? "successful" : "failed"));
        g = new mathJS.Generator(function(x) {
          return x;
        });
        while (g.hasNext()) {
          tmp = g.next();
        }
        tmp = g.next();
        return "done";
      };
    }

    return DiscreteGenerator;

  })(_mathJS.AbstractGenerator);

  mathJS.ContinuousGenerator = (function(superClass) {
    extend(ContinuousGenerator, superClass);

    function ContinuousGenerator(f, minX, maxX, stepSize, maxIndex, tuple) {
      if (minX == null) {
        minX = 0;
      }
      if (maxX == null) {
        maxX = Infinity;
      }
      if (stepSize == null) {
        stepSize = mathJS.config.number.real.distance;
      }
      if (maxIndex == null) {
        maxIndex = mathJS.config.generator.maxIndex;
      }
      this.f = f;
      this.inverseF = f.getInverse();
      this.minX = minX;
      this.maxX = maxX;
      this.stepSize = stepSize;
      this.maxIndex = maxIndex;
      this.tuple = tuple;
      this.x = minX;
      this.overflowed = false;
      this.index = 0;
    }

    Object.defineProperties(ContinuousGenerator.prototype, {
      "function": {
        get: function() {
          return this.f;
        },
        set: function(f) {
          this.f = f;
          this.inverseF = f.getInverse();
          return this;
        }
      }
    });

    ContinuousGenerator.product = function() {
      var generators;
      generators = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return new mathJS.Generator(null, 0, Infinity, null, null, new mathJS.Tuple(generators));
    };

    ContinuousGenerator.or = function() {};

    ContinuousGenerator.and = function() {};


    /**
    * Indicates whether the set the generator creates contains the given value or not.
    * @method generates
    *
     */

    ContinuousGenerator.prototype.generates = function(y) {
      if (this.f.range.contains(y)) {
        if (this.inverseF != null) {
          return this.inverseF["eval"](y);
        }
        return;
      }
      return false;
    };

    ContinuousGenerator.prototype["eval"] = function(n) {
      if (this.tuple != null) {
        return this.tuple["eval"](n);
      }
      if (this.f["eval"] != null) {
        this.f["eval"](n);
      }
      return this.f.call(this, n);
    };

    ContinuousGenerator.prototype.hasNext = function() {
      var g, i, l, len1, ref;
      if (this.tuple != null) {
        ref = this.tuple.elems;
        for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
          g = ref[i];
          if (g.hasNext()) {
            return true;
          }
        }
        return false;
      }
      return !this.overflowed && this.x < this.maxX && this.index < this.maxIndex;
    };

    ContinuousGenerator.prototype._incX = function() {
      this.index++;
      this.x = this.minX + this.index * this.stepSize;
      if (this.x > this.maxX) {
        this.x = this.minX;
        this.index = 0;
        this.overflowed = true;
      }
      return this.x;
    };

    ContinuousGenerator.prototype.next = function() {
      var g, generator, i, maxI, res;
      if (this.tuple != null) {
        res = this["eval"]((function() {
          var l, len1, ref, results;
          ref = this.tuple.elems;
          results = [];
          for (l = 0, len1 = ref.length; l < len1; l++) {
            g = ref[l];
            results.push(g.x);
          }
          return results;
        }).call(this));

        /*
        0 0
        0 1
        1 0
        1 1
         */
        i = 0;
        maxI = this.tuple.length;
        generator = this.tuple.first;
        generator._incX();
        while (i < maxI && generator.overflowed) {
          generator.overflowed = false;
          generator = this.tuple.at(++i);
          if (generator != null) {
            generator._incX();
          }
        }
        return res;
      }
      res = this["eval"](this.x);
      this._incX();
      return res;
    };

    ContinuousGenerator.prototype.reset = function() {
      this.x = this.minX;
      this.index = 0;
      return this;
    };

    if (DEBUG) {
      ContinuousGenerator.test = function() {
        var g, g1, g2, res, tmp;
        g = new mathJS.Generator(function(x) {
          return 3 * x * x + 2 * x - 5;
        }, -10, 10, 0.2);
        res = [];
        while (g.hasNext()) {
          tmp = g.next();
          res.push(tmp);
        }
        tmp = g.next();
        res.push(tmp);
        console.log("simple test:", (res.length === ((g.maxX - g.minX) / g.stepSize + 1) ? "successful" : "failed"));
        g1 = new mathJS.Generator(function(x) {
          return x;
        }, 0, 5, 0.5);
        g2 = new mathJS.Generator(function(x) {
          return 2 * x;
        }, -2, 10, 2);
        g = mathJS.Generator.product(g1, g2);
        res = [];
        while (g.hasNext()) {
          tmp = g.next();
          res.push(tmp);
        }
        tmp = g.next();
        res.push(tmp);
        console.log("tuple test:", (res.length === ((g1.maxX - g1.minX) / g1.stepSize + 1) * ((g2.maxX - g2.minX) / g2.stepSize + 1) ? "successful" : "failed"));
        g = new mathJS.Generator(function(x) {
          return x;
        });
        while (g.hasNext()) {
          tmp = g.next();
        }
        tmp = g.next();
        return "done";
      };
    }

    return ContinuousGenerator;

  })(_mathJS.AbstractGenerator);


  /**
  * Domain ranks are like so:
  * N -> 0
  * Z -> 1
  * Q -> 2
  * I -> 2
  * R -> 3
  * C -> 4
  * ==> union: take greater rank (if equal (and unequal names) take next greater rank)
  * ==> intersection: take smaller rank (if equal (and unequal names) take empty set)
  *
   */

  _mathJS.Sets.Domain = (function(superClass) {
    var CLASS;

    extend(Domain, superClass);

    CLASS = Domain;

    Domain["new"] = function() {
      return new CLASS();
    };

    Domain._byRank = function(rank) {
      var domain, name, ref;
      ref = mathJS.Domains;
      for (name in ref) {
        domain = ref[name];
        if (domain.rank === rank) {
          return domain;
        }
      }
      return null;
    };

    function Domain(name, rank, isCountable) {
      this.isDomain = true;
      this.name = name;
      this.rank = rank;
      this.isCountable = isCountable;
    }

    Domain.prototype.clone = function() {
      return this.constructor["new"]();
    };

    Domain.prototype.size = function() {
      return Infinity;
    };

    Domain.prototype.equals = function(set) {
      return set instanceof this.constructor;
    };

    Domain.prototype.intersection = function(set) {
      if (set.isDomain) {
        if (this.name === set.name) {
          return this;
        }
        if (this.rank < set.rank) {
          return this;
        }
        if (this.rank > set.rank) {
          return set;
        }
        return new mathJS.Set();
      }
      return false;
    };

    Domain.prototype.union = function(set) {
      if (set.isDomain) {
        if (this.name === set.name) {
          return this;
        }
        if (this.rank > set.rank) {
          return this;
        }
        if (this.rank < set.rank) {
          return set;
        }
        return CLASS._byRank(this.rank + 1);
      }
      return false;
    };

    Domain._makeAliases();

    return Domain;

  })(_mathJS.AbstractSet);

  mathJS.Sets.N = (function(superClass) {
    var CLASS;

    extend(N, superClass);

    CLASS = N;

    N["new"] = function() {
      return new CLASS();
    };

    function N() {
      N.__super__.constructor.call(this, "N", 0, true);
    }

    N.prototype.contains = function(x) {
      return mathJS.isInt(x) || new mathJS.Int(x).equals(x);
    };


    /**
    * This method checks if `this` is a subset of the given set `set`. Since equality must be checked by checking an arbitrary number of values this method actually does the same as `this.equals()`. For `this.equals()` the number of compared elements is 10x bigger.
    *
     */

    N.prototype.isSubsetOf = function(set, n) {
      if (n == null) {
        n = mathJS.settings.set.maxIterations;
      }
      return this.equals(set, n * 10);
    };

    N.prototype.isSupersetOf = function(set) {
      if (this._isSet(set)) {
        return set.isSubsetOf(this);
      }
      return false;
    };

    N.prototype.union = function(set, n, matches) {
      var checker, generator, self;
      if (n == null) {
        n = mathJS.settings.set.maxIterations;
      }
      if (matches == null) {
        matches = mathJS.settings.set.maxMatches;
      }
      checker = function(elem) {
        return self.checker(elem) || set.checker(elem);
      };
      generator = function() {};
      if (set instanceof mathJS.DiscreteSet || (typeof set["instanceof"] === "function" ? set["instanceof"](mathJS.DiscreteSet) : void 0)) {

      } else if (set instanceof mathJS.Set || (typeof set["instanceof"] === "function" ? set["instanceof"](mathJS.Set) : void 0)) {
        if (mathJS["instanceof"](set, mathJS.Set.N)) {
          return this;
        }
        if (mathJS["instanceof"](set, mathJS.Domains.Q) || mathJS["instanceof"](set, mathJS.Domains.R)) {
          return set;
        }
        self = this;
      }
      return null;
    };

    N.prototype.intersect = function(set) {
      var checker, commonElements, elem, f1, f1Elem, f1Elems, f2, f2Elem, f2Elems, found, i, l, len1, len2, len3, m, o, ops, q, x, y1, y2;
      checker = function(elem) {
        return self.checker(elem) && set.checker(elem);
      };
      commonElements = [];
      x = 0;
      m = 0;
      f1 = this.generator;
      f2 = set.generator;
      f1Elems = [];
      f2Elems = [];
      while (x < n && m < matches) {
        y1 = f1(x);
        y2 = f2(x);
        if (mathJS.gt(y1, y2)) {
          found = false;
          for (i = l = 0, len1 = f1Elems.length; l < len1; i = ++l) {
            f1Elem = f1Elems[i];
            if (!(mathJS.equals(y2, f1Elem))) {
              continue;
            }
            m++;
            found = true;
            commonElements.push(y2);
            f1Elems = f1Elems.slice(i + 1);
            f2Elems = [];
            break;
          }
          if (!found) {
            f1Elems.push(y1);
            f2Elems.push(y2);
          }
        } else if (mathJS.lt(y1, y2)) {
          found = false;
          for (i = o = 0, len2 = f2Elems.length; o < len2; i = ++o) {
            f2Elem = f2Elems[i];
            if (!(mathJS.equals(y1, f2Elem))) {
              continue;
            }
            m++;
            found = true;
            commonElements.push(y1);
            f2Elems = f2Elems.slice(i + 1);
            f1Elems = [];
            break;
          }
          if (!found) {
            f1Elems.push(y1);
            f2Elems.push(y2);
          }
        } else {
          m++;
          commonElements.push(y1);
          f1Elems = [];
          f2Elems = [];
        }
        x++;
      }
      console.log("x=" + x, "m=" + m, commonElements);
      ops = [];
      for (q = 0, len3 = commonElements.length; q < len3; q++) {
        elem = commonElements[q];
        true;
      }
    };

    N.prototype.intersects = function(set) {
      return this.intersection(set).size > 0;
    };

    N.prototype.disjoint = function(set) {
      return this.intersection(set).size === 0;
    };

    N.prototype.complement = function() {
      if (this.universe != null) {
        return this.universe.without(this);
      }
      return new mathJS.EmptySet();
    };


    /**
    * a.without b => returns: removed all common elements from a
    *
     */

    N.prototype.without = function(set) {};

    N.prototype.cartesianProduct = function(set) {};

    N.prototype.times = N.prototype.cartesianProduct;

    return N;

  })(_mathJS.Sets.Domain);

  (function() {
    return Object.defineProperties(mathJS.Domains, {
      N: {
        value: new mathJS.Sets.N(),
        writable: false,
        enumerable: true,
        configurable: false
      }
    });
  })();

  mathJS.Sets.Z = (function(superClass) {
    var CLASS;

    extend(Z, superClass);

    CLASS = Z;

    Z["new"] = function() {
      return new CLASS();
    };

    function Z() {
      Z.__super__.constructor.call(this, "Z", 1, true);
    }

    Z.prototype.contains = function(x) {
      return new mathJS.Number(x).equals(x);
    };


    /**
    * This method checks if `this` is a subset of the given set `set`. Since equality must be checked by checking an arbitrary number of values this method actually does the same as `this.equals()`. For `this.equals()` the number of compared elements is 10x bigger.
    *
     */

    Z.prototype.isSubsetOf = function(set, n) {
      if (n == null) {
        n = mathJS.settings.set.maxIterations;
      }
      return this.equals(set, n * 10);
    };

    Z.prototype.isSupersetOf = function(set) {
      if (this._isSet(set)) {
        return set.isSubsetOf(this);
      }
      return false;
    };

    Z.prototype.complement = function() {
      if (this.universe != null) {
        return this.universe.without(this);
      }
      return new mathJS.EmptySet();
    };


    /**
    * a.without b => returns: removed all common elements from a
    *
     */

    Z.prototype.without = function(set) {};

    Z.prototype.cartesianProduct = function(set) {};

    Z._makeAliases();

    return Z;

  })(_mathJS.Sets.Domain);

  (function() {
    return Object.defineProperties(mathJS.Domains, {
      Z: {
        value: new mathJS.Sets.Z(),
        writable: false,
        enumerable: true,
        configurable: false
      }
    });
  })();

  mathJS.Sets.Q = (function(superClass) {
    var CLASS;

    extend(Q, superClass);

    CLASS = Q;

    Q["new"] = function() {
      return new CLASS();
    };

    function Q() {
      Q.__super__.constructor.call(this, "Q", 2, true);
    }

    Q.prototype.contains = function(x) {
      return new mathJS.Number(x).equals(x);
    };


    /**
    * This method checks if `this` is a subset of the given set `set`. Since equality must be checked by checking an arbitrary number of values this method actually does the same as `this.equals()`. For `this.equals()` the number of compared elements is 10x bigger.
    *
     */

    Q.prototype.isSubsetOf = function(set, n) {
      if (n == null) {
        n = mathJS.settings.set.maxIterations;
      }
      return this.equals(set, n * 10);
    };

    Q.prototype.isSupersetOf = function(set) {
      if (this._isSet(set)) {
        return set.isSubsetOf(this);
      }
      return false;
    };

    Q.prototype.complement = function() {
      if (this.universe != null) {
        return this.universe.without(this);
      }
      return new mathJS.EmptySet();
    };


    /**
    * a.without b => returns: removed all common elements from a
    *
     */

    Q.prototype.without = function(set) {};

    Q.prototype.cartesianProduct = function(set) {};

    Q._makeAliases();

    return Q;

  })(_mathJS.Sets.Domain);

  (function() {
    return Object.defineProperties(mathJS.Domains, {
      Q: {
        value: new mathJS.Sets.Q(),
        writable: false,
        enumerable: true,
        configurable: false
      }
    });
  })();

  mathJS.Sets.I = (function(superClass) {
    var CLASS;

    extend(I, superClass);

    CLASS = I;

    I["new"] = function() {
      return new CLASS();
    };

    function I() {
      I.__super__.constructor.call(this, "I", 2, false);
    }

    I.prototype.contains = function(x) {
      return new mathJS.Number(x).equals(x);
    };


    /**
    * This method checks if `this` is a subset of the given set `set`. Since equality must be checked by checking an arbitrary number of values this method actually does the same as `this.equals()`. For `this.equals()` the number of compared elements is 10x bigger.
    *
     */

    I.prototype.isSubsetOf = function(set, n) {
      if (n == null) {
        n = mathJS.settings.set.maxIterations;
      }
      return this.equals(set, n * 10);
    };

    I.prototype.isSupersetOf = function(set) {
      if (this._isSet(set)) {
        return set.isSubsetOf(this);
      }
      return false;
    };

    I.prototype.complement = function() {
      if (this.universe != null) {
        return this.universe.without(this);
      }
      return new mathJS.EmptySet();
    };


    /**
    * a.without b => returns: removed all common elements from a
    *
     */

    I.prototype.without = function(set) {};

    I.prototype.cartesianProduct = function(set) {};

    I._makeAliases();

    return I;

  })(_mathJS.Sets.Domain);

  (function() {
    return Object.defineProperties(mathJS.Domains, {
      I: {
        value: new mathJS.Sets.I(),
        writable: false,
        enumerable: true,
        configurable: false
      }
    });
  })();

  mathJS.Sets.R = (function(superClass) {
    var CLASS;

    extend(R, superClass);

    CLASS = R;

    R["new"] = function() {
      return new CLASS();
    };

    function R() {
      R.__super__.constructor.call(this, "R", 3, false);
    }

    R.prototype.contains = function(x) {
      return new mathJS.Number(x).equals(x);
    };


    /**
    * This method checks if `this` is a subset of the given set `set`. Since equality must be checked by checking an arbitrary number of values this method actually does the same as `this.equals()`. For `this.equals()` the number of compared elements is 10x bigger.
    *
     */

    R.prototype.isSubsetOf = function(set, n) {
      if (n == null) {
        n = mathJS.settings.set.maxIterations;
      }
      return this.equals(set, n * 10);
    };

    R.prototype.isSupersetOf = function(set) {
      if (this._isSet(set)) {
        return set.isSubsetOf(this);
      }
      return false;
    };

    R.prototype.complement = function() {
      if (this.universe != null) {
        return this.universe.without(this);
      }
      return new mathJS.EmptySet();
    };


    /**
    * a.without b => returns: removed all common elements from a
    *
     */

    R.prototype.without = function(set) {};

    R.prototype.cartesianProduct = function(set) {};

    R._makeAliases();

    return R;

  })(_mathJS.Sets.Domain);

  (function() {
    return Object.defineProperties(mathJS.Domains, {
      R: {
        value: new mathJS.Sets.R(),
        writable: false,
        enumerable: true,
        configurable: false
      }
    });
  })();

  mathJS.Sets.C = (function(superClass) {
    var CLASS;

    extend(C, superClass);

    CLASS = C;

    C["new"] = function() {
      return new CLASS();
    };

    function C() {
      C.__super__.constructor.call(this, "C", 4, false);
    }

    C.prototype.contains = function(x) {
      return new mathJS.Number(x).equals(x);
    };


    /**
    * This method checks if `this` is a subset of the given set `set`. Since equality must be checked by checking an arbitrary number of values this method actually does the same as `this.equals()`. For `this.equals()` the number of compared elements is 10x bigger.
    *
     */

    C.prototype.isSubsetOf = function(set, n) {
      if (n == null) {
        n = mathJS.settings.set.maxIterations;
      }
      return this.equals(set, n * 10);
    };

    C.prototype.isSupersetOf = function(set) {
      if (this._isSet(set)) {
        return set.isSubsetOf(this);
      }
      return false;
    };

    C.prototype.complement = function() {
      if (this.universe != null) {
        return this.universe.without(this);
      }
      return new mathJS.EmptySet();
    };


    /**
    * a.without b => returns: removed all common elements from a
    *
     */

    C.prototype.without = function(set) {};

    C.prototype.cartesianProduct = function(set) {};

    C._makeAliases();

    return C;

  })(_mathJS.Sets.Domain);

  (function() {
    return Object.defineProperties(mathJS.Domains, {
      C: {
        value: new mathJS.Sets.C(),
        writable: false,
        enumerable: true,
        configurable: false
      }
    });
  })();

  mathJS.Integral = (function() {
    var CLASS, _solvePrepareVars;

    CLASS = Integral;

    if (DEBUG) {
      Integral.test = function() {
        var i, start, start2;
        i = new mathJS.Integral(function(x) {
          return -2 * x * x - 3 * x + 10;
        }, -3, 1);
        start = Date.now();
        console.log(i.solve(false, 0.00000000000001), Date.now() - start);
        start = Date.now();
        i.solveAsync(function(res) {
          return console.log(res, "async took:", Date.now() - start);
        }, false, 0.0000001);
        start2 = Date.now();
        console.log(i.solve(), Date.now() - start2);
        return "test done";
      };
    }

    function Integral(integrand, leftBoundary, rightBoundary, integrationVariable) {
      if (leftBoundary == null) {
        leftBoundary = -Infinity;
      }
      if (rightBoundary == null) {
        rightBoundary = Infinity;
      }
      if (integrationVariable == null) {
        integrationVariable = new mathJS.Variable("x");
      }
      this.integrand = integrand;
      this.leftBoundary = leftBoundary;
      this.rightBoundary = rightBoundary;
      this.integrationVariable = integrationVariable;
      this.settings = null;
    }

    _solvePrepareVars = function(from, to, abs, stepSize) {
      var diff, modVal, tmp;
      if (abs === false) {
        modVal = mathJS.id;
      } else {
        modVal = function(x) {
          return Math.abs(x);
        };
      }
      from = from.value || from;
      to = to.value || to;
      if (to < from) {
        tmp = to;
        to = from;
        from = tmp;
      }
      if ((diff = to - from) < stepSize) {
        stepSize = diff * 0.001;
      }
      return {
        modVal: modVal,
        from: from,
        to: to,
        stepSize: stepSize
      };
    };

    Integral.solve = function(integrand, from, to, abs, stepSize, settings) {
      var halfStepSize, i, l, modVal, ref, ref1, ref2, res, steps, vars, x2, y1, y2;
      if (abs == null) {
        abs = false;
      }
      if (stepSize == null) {
        stepSize = 0.01;
      }
      if (settings == null) {
        settings = {};
      }
      vars = _solvePrepareVars(from, to, abs, stepSize);
      modVal = vars.modVal;
      from = vars.from;
      to = vars.to;
      stepSize = vars.stepSize;
      if ((steps = (to - from) / stepSize) > settings.maxSteps || mathJS.settings.integral.maxSteps) {
        throw new mathJS.Errors.CalculationExceedanceError("Too many calculations (" + (steps.toExponential()) + ") ahead! Either adjust mathJS.Integral.settings.maxSteps, set the Integral\"s instance\"s settings or pass settings to mathJS.Integral.solve() if you really need that many calculations.");
      }
      res = 0;
      halfStepSize = 0.5 * stepSize;
      y1 = integrand(from);
      if (DEBUG) {
        i = 0;
      }
      for (x2 = l = ref = from + stepSize, ref1 = to, ref2 = stepSize; ref2 > 0 ? l <= ref1 : l >= ref1; x2 = l += ref2) {
        if (DEBUG) {
          i++;
        }
        y2 = integrand(x2);
        if (mathJS.sign(y1) === mathJS.sign(y2)) {
          res += modVal((y1 + y2) * halfStepSize);
        }
        y1 = y2;
      }
      if (DEBUG) {
        console.log("made", i, "calculations");
      }
      return res;
    };


    /**
    * For better calculation performance of the integral decrease delay and numBlocks.
    * For better overall performance increase them.
    * @public
    * @static
    * @method solveAsync
    * @param integrand {Function}
    * @param from {Number}
    * @param to {Number}
    * @param callback {Function}
    * @param abs {Boolean}
    * Optional. Indicates whether areas below the graph are negative or not.
    * Default is false.
    * @param stepSize {Number}
    * Optional. Defines the width of each trapezoid. Default is 0.01.
    * @param delay {Number}
    * Optional. Defines the time to pass between blocks of calculations.
    * Default is 2ms.
    * @param numBlocks {Number}
    * Optional. Defines the number of calculation blocks.
    * Default is 100.
    *
     */

    Integral.solveAsync = function(integrand, from, to, callback, abs, stepSize, delay, numBlocks) {
      var block, blockSize, f, res;
      if (delay == null) {
        delay = 2;
      }
      if (numBlocks == null) {
        numBlocks = 100;
      }
      if (callback == null) {
        return false;
      }
      blockSize = (to - from) / numBlocks;
      block = 0;
      res = 0;
      f = function(from, to) {
        if (block++ === numBlocks) {
          return callback(res);
        }
        res += CLASS.solve(integrand, from, to, abs, stepSize);
        setTimeout(function() {
          return f(to, to + blockSize);
        }, delay);
        return true;
      };
      f(from, from + blockSize);
      return this;
    };

    Integral.prototype.solve = function(abs, stepSize) {
      return CLASS.solve(this.integrand, this.leftBoundary, this.rightBoundary, abs, stepSize);
    };

    Integral.prototype.solveAsync = function(callback, abs, stepSize) {
      return CLASS.solveAsync(this.integrand, this.leftBoundary, this.rightBoundary, callback, abs, stepSize);
    };

    return Integral;

  })();

  mathJS.Vector = (function() {
    Vector.prototype._isVectorLike = function(v) {
      return v instanceof mathJS.Vector || (typeof v["instanceof"] === "function" ? v["instanceof"](mathJS.Vector) : void 0);
    };

    Vector._isVectorLike = Vector.prototype._isVectorLike;

    function Vector(values) {
      var l, len1, val;
      this.values = values;
      if (DEBUG) {
        for (l = 0, len1 = values.length; l < len1; l++) {
          val = values[l];
          if (!mathJS.isMathJSNum(val)) {
            console.warn("invalid value:", val);
          }
        }
      }
    }

    Vector.prototype.equals = function(v) {
      var i, l, len1, ref, vValue, val;
      if (!this._isVectorLike(v)) {
        return false;
      }
      ref = this.values;
      for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
        val = ref[i];
        vValue = v.values[i];
        if (!(typeof val.equals === "function" ? val.equals(vValue) : void 0) && val !== vValue) {
          return false;
        }
      }
      return true;
    };

    Vector.prototype.clone = function() {
      return new TD.Vector(this.values);
    };

    Vector.prototype.move = function(v) {
      var i, l, len1, ref, vValue, val;
      if (!this._isVectorLike(v)) {
        return this;
      }
      ref = v.values;
      for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
        val = ref[i];
        vValue = v.values[i];
        this.values[i] = (typeof vValue.plus === "function" ? vValue.plus(val) : void 0) || (typeof val.plus === "function" ? val.plus(vValue) : void 0) || (vValue + val);
      }
      return this;
    };

    Vector.prototype.moveBy = Vector.move;

    Vector.prototype.moveTo = function(p) {
      var i, l, len1, ref, vValue, val;
      if (!this._isVectorLike(v)) {
        return this;
      }
      ref = v.values;
      for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
        val = ref[i];
        vValue = v.values[i];
        this.values[i] = vValue.value || vValue;
      }
      return this;
    };

    Vector.prototype.multiply = function(r) {
      if (Math.isNum(r)) {
        return new TD.Point(this.x * r, this.y * r);
      }
      return null;
    };

    Vector.prototype.times = Vector.multiply;

    Vector.prototype.magnitude = function() {
      var i, l, len1, ref, sum, val;
      sum = 0;
      ref = this.values;
      for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
        val = ref[i];
        sum += val * val;
      }
      return Math.sqrt(sum);
    };


    /**
     * This method calculates the distance between 2 points.
     * It"s a shortcut for substracting 2 vectors and getting that vector"s magnitude (because no new object is created).
     * For that reason this method should be used for pure distance calculations.
     *
     * @method distanceTo
     * @param {Point} p
     * @return {Number} Distance between this point and p.
    *
     */

    Vector.prototype.distanceTo = function(v) {
      var i, l, len1, ref, sum, val;
      sum = 0;
      ref = this.values;
      for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
        val = ref[i];
        sum += (val - v.values[i]) * (val - v.values[i]);
      }
      return Math.sqrt(sum);
    };

    Vector.prototype.add = function(v) {
      var i, l, len1, ref, vValue, val, values;
      if (!this._isVectorLike(v)) {
        return null;
      }
      values = [];
      ref = v.values;
      for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
        val = ref[i];
        vValue = v.values[i];
        values.push((typeof vValue.plus === "function" ? vValue.plus(val) : void 0) || (typeof val.plus === "function" ? val.plus(vValue) : void 0) || (vValue + val));
      }
      return new mathJS.Vector(values);
    };

    Vector.prototype.plus = Vector.add;

    Vector.prototype.substract = function(p) {
      if (isPointLike(p)) {
        return new TD.Point(this.x - p.x, this.y - p.y);
      }
      return null;
    };

    Vector.prototype.minus = Vector.substract;

    Vector.prototype.xyRatio = function() {
      return this.x / this.y;
    };

    Vector.prototype.toArray = function() {
      return [this.x, this.y];
    };

    Vector.prototype.isPositive = function() {
      return this.x >= 0 && this.y >= 0;
    };


    /**
     * Returns the angle of a vector. Beware that the angle is measured in counter clockwise direction beginning at 0 which equals the x axis in positive direction.
     * So on a computer grid the angle won"t be what you expect! Use anglePC() in that case!
     *
     * @method angle
     * @return {Number} Angle of the vector in degrees. 0 degrees means pointing to the right.
    *
     */

    Vector.prototype.angle = function() {
      if (this.x >= 0 && this.y >= 0) {
        return Math.radToDeg(Math.atan(Math.abs(this.y) / Math.abs(this.x))) % 360;
      }
      if (this.x < 0 && this.y > 0) {
        return (90 + Math.radToDeg(Math.atan(Math.abs(this.x) / Math.abs(this.y)))) % 360;
      }
      if (this.x < 0 && this.y < 0) {
        return (180 + Math.radToDeg(Math.atan(Math.abs(this.y) / Math.abs(this.x)))) % 360;
      }
      return (270 + Math.radToDeg(Math.atan(Math.abs(this.x) / Math.abs(this.y)))) % 360;
    };


    /**
     * Returns the angle of a vector. 0 means pointing to the top. Clockwise.
     *
     * @method anglePC
     * @return {Number} Angle of the vector in degrees. 0 degrees means pointing to the right.
    *
     */

    Vector.prototype.anglePC = function() {
      if (this.x >= 0 && this.y >= 0) {
        return (90 + Math.radToDeg(Math.atan(Math.abs(this.y) / Math.abs(this.x)))) % 360;
      }
      if (this.x < 0 && this.y > 0) {
        return (180 + Math.radToDeg(Math.atan(Math.abs(this.x) / Math.abs(this.y)))) % 360;
      }
      if (this.x < 0 && this.y < 0) {
        return (270 + Math.radToDeg(Math.atan(Math.abs(this.y) / Math.abs(this.x)))) % 360;
      }
      return Math.radToDeg(Math.atan(Math.abs(this.x) / Math.abs(this.y))) % 360;
    };


    /**
     * Returns a random Point within a given radius.
     *
     * @method randPointInRadius
     * @param {Number} radius
     * Default is 10 (pixels). Must not be smaller than 0.
     * @param {Boolean} random
     * Indicates whether the given radius is the maximum or exact distance between the 2 points.
     * @return {Number} Random Point.
    *
     */

    Vector.prototype.randPointInRadius = function(radius, random) {
      var angle, x, y;
      if (radius == null) {
        radius = 5;
      }
      if (random == null) {
        random = false;
      }
      angle = Math.degToRad(Math.randNum(0, 360));
      if (random === true) {
        radius = Math.randNum(0, radius);
      }
      x = radius * Math.cos(angle);
      y = radius * Math.sin(angle);
      return this.add(new TD.Point(x, y));
    };

    return Vector;

  })();

  mathJS.Initializer = (function() {
    function Initializer() {}

    Initializer.start = function() {
      return mathJS.Algorithms.ShuntingYard.init();
    };

    return Initializer;

  })();

  mathJS.Initializer.start();

  if (DEBUG) {
    diff = Date.now() - startTime;
    console.log("time to load mathJS: ", diff, "ms");
    if (diff > 100) {
      console.warn("LOADING TIME CRITICAL!");
    }
  }

}).call(this);
