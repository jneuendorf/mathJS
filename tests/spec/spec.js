// Generated by CoffeeScript 1.9.3
(function() {
  describe("Fraction (fractions)", function() {
    it("creation", function() {
      expect(mathJS.Fraction["new"](1, 2).numerator).toBe(1);
      expect(mathJS.Fraction["new"](1, 2).denominator).toBe(2);
      return expect(mathJS.Fraction.parse("12e-2").equals(mathJS.Fraction["new"](12, 100))).toBe(true);
    });
    it("comparison", function() {
      var n1, n2;
      n1 = mathJS.Fraction["new"](42);
      n2 = mathJS.Fraction["new"](1337.123);
      expect(mathJS.Fraction["new"](42).equals(n1)).toBe(true);
      expect(n1.lessThan(n2)).toBe(true);
      expect(n1.greaterThan(n2)).toBe(false);
      expect(n2.lessThan(n1)).toBe(false);
      expect(n2.greaterThan(n1)).toBe(true);
      expect(n1.lessThanOrEqualTo(n1)).toBe(true);
      expect(n1.greaterThanOrEqualTo(n1)).toBe(true);
      expect(n1.lessThanOrEqualTo(n2)).toBe(true);
      expect(n1.greaterThanOrEqualTo(n2)).toBe(false);
      expect(n2.lessThanOrEqualTo(n1)).toBe(false);
      return expect(n2.greaterThanOrEqualTo(n1)).toBe(true);
    });
    it("basic operations", function() {
      var diff, n1, n2, product, quotient, sum;
      n1 = mathJS.Number["new"](4);
      n2 = mathJS.Number["new"](5);
      sum = mathJS.Number["new"](9);
      diff = mathJS.Number["new"](-1);
      product = mathJS.Number["new"](20);
      quotient = mathJS.Number["new"](0.8);
      expect(n1.plus(n2).equals(9)).toBe(true);
      expect(n1.plus(n2).equals(sum)).toBe(true);
      expect(n1.minus(n2).equals(-1)).toBe(true);
      expect(n1.minus(n2).equals(diff)).toBe(true);
      expect(n1.times(n2).equals(20)).toBe(true);
      expect(n1.times(n2).equals(product)).toBe(true);
      expect(n1.divide(n2).equals(0.8)).toBe(true);
      return expect(n1.divide(n2).equals(quotient)).toBe(true);
    });
    it("advanced operations", function() {
      var cube, curt, n1, n2, n3, n4, pow, reciprocal, root, sign, sqrt, square;
      n1 = mathJS.Number["new"](4);
      n2 = mathJS.Number["new"](8);
      n3 = mathJS.Number["new"](625);
      n4 = mathJS.Number["new"](-42);
      square = mathJS.Number["new"](16);
      cube = mathJS.Number["new"](64);
      sqrt = mathJS.Number["new"](2);
      curt = mathJS.Number["new"](2);
      root = mathJS.Number["new"](5);
      reciprocal = mathJS.Number["new"](1 / 8);
      pow = mathJS.Number["new"](625);
      sign = mathJS.Number["new"](1);
      expect(n1.square().equals(16)).toBe(true);
      expect(n1.square().equals(square)).toBe(true);
      expect(n1.cube().equals(64)).toBe(true);
      expect(n1.cube().equals(cube)).toBe(true);
      expect(n1.sqrt().equals(2)).toBe(true);
      expect(n1.sqrt().equals(sqrt)).toBe(true);
      expect(n2.curt().equals(2)).toBe(true);
      expect(n2.curt().equals(curt)).toBe(true);
      expect(n3.root(4).equals(5)).toBe(true);
      expect(n3.root(mathJS.Number["new"](4)).equals(root)).toBe(true);
      expect(n2.reciprocal().equals(0.125)).toBe(true);
      expect(n2.reciprocal().equals(reciprocal)).toBe(true);
      expect(n1.pow(4).root(4).equals(n1)).toBe(true);
      expect(n2.pow(mathJS.Number["new"](8)).root(8).equals(n2)).toBe(true);
      expect(n1.sign()).toBe(1);
      expect(n1.sign(true)).toBe(1);
      expect(n1.sign(false).equals(mathJS.Number["new"](1))).toBe(true);
      expect(n4.sign()).toBe(-1);
      expect(n4.sign(false).equals(mathJS.Number["new"](-1))).toBe(true);
      expect(n1.negate().equals(-4)).toBe(true);
      return expect(n4.negate().equals(42)).toBe(true);
    });
    return it("conversion", function() {
      var n1, n2, n3;
      n1 = mathJS.Number["new"](0.8);
      n2 = mathJS.Number["new"](1e-14);
      n3 = mathJS.Number["new"](1e-5);
      expect(n1.toString()).toBe("0.8");
      expect(n2.toString()).toBe("1e-14");
      expect(n2.toString("0.00000000000000000000")).toBe("0.00000000000001000000");
      expect(n3.toString()).toBe("0.00001");
      expect(n1.toNumber().equals(n1)).toBe(true);
      return expect(n1.toInt().equals(mathJS.Int["new"](n1))).toBe(true);
    });
  });

  describe("Int (integers)", function() {
    it("creation", function() {
      expect(mathJS.Int["new"](12).value).toBe(12);
      expect(mathJS.Int.parse("12").equals(mathJS.Int["new"](12))).toBe(true);
      return expect(mathJS.Int.parse("12.12345").equals(mathJS.Int["new"](12))).toBe(true);
    });
    it("comparison", function() {
      var n1, n2;
      n1 = mathJS.Number["new"](42);
      n2 = mathJS.Number["new"](1337);
      expect(mathJS.Number["new"](42).equals(n1)).toBe(true);
      expect(n1.lessThan(n2)).toBe(true);
      expect(n1.greaterThan(n2)).toBe(false);
      expect(n2.lessThan(n1)).toBe(false);
      expect(n2.greaterThan(n1)).toBe(true);
      expect(n1.lessThanOrEqualTo(n1)).toBe(true);
      expect(n1.greaterThanOrEqualTo(n1)).toBe(true);
      expect(n1.lessThanOrEqualTo(n2)).toBe(true);
      expect(n1.greaterThanOrEqualTo(n2)).toBe(false);
      expect(n2.lessThanOrEqualTo(n1)).toBe(false);
      return expect(n2.greaterThanOrEqualTo(n1)).toBe(true);
    });
    it("basic operations", function() {
      var diff, n1, n2, product, quotient, sum;
      n1 = mathJS.Int["new"](4);
      n2 = mathJS.Int["new"](5);
      sum = mathJS.Int["new"](9);
      diff = mathJS.Int["new"](-1);
      product = mathJS.Int["new"](20);
      quotient = mathJS.Number["new"](0.8);
      expect(n1.plus(n2).equals(9)).toBe(true);
      expect(n1.plus(n2).equals(sum)).toBe(true);
      expect(n1.minus(n2).equals(-1)).toBe(true);
      expect(n1.minus(n2).equals(diff)).toBe(true);
      expect(n1.times(n2).equals(20)).toBe(true);
      expect(n1.times(n2).equals(product)).toBe(true);
      expect(n1.divide(n2).equals(0.8)).toBe(true);
      return expect(n1.divide(n2).equals(quotient)).toBe(true);
    });
    it("advanced operations", function() {
      var cube, curt, n1, n2, n3, n4, pow, reciprocal, root, sign, sqrt, square;
      n1 = mathJS.Int["new"](4);
      n2 = mathJS.Int["new"](8);
      n3 = mathJS.Int["new"](625);
      n4 = mathJS.Int["new"](-42);
      square = mathJS.Int["new"](16);
      cube = mathJS.Int["new"](64);
      sqrt = mathJS.Int["new"](2);
      curt = mathJS.Int["new"](2);
      root = mathJS.Int["new"](5);
      reciprocal = mathJS.Number["new"](1 / 8);
      pow = mathJS.Int["new"](625);
      sign = mathJS.Int["new"](1);
      expect(n1.square().equals(16)).toBe(true);
      expect(n1.square().equals(square)).toBe(true);
      expect(n1.cube().equals(64)).toBe(true);
      expect(n1.cube().equals(cube)).toBe(true);
      expect(n1.sqrt().equals(2)).toBe(true);
      expect(n1.sqrt().equals(sqrt)).toBe(true);
      expect(n2.curt().equals(2)).toBe(true);
      expect(n2.curt().equals(curt)).toBe(true);
      expect(n3.root(4).equals(5)).toBe(true);
      expect(n3.root(mathJS.Number["new"](4)).equals(root)).toBe(true);
      expect(n2.reciprocal().equals(0.125)).toBe(true);
      expect(n2.reciprocal().equals(reciprocal)).toBe(true);
      expect(n1.pow(4).root(4).equals(n1)).toBe(true);
      expect(n2.pow(mathJS.Number["new"](8)).root(8).equals(n2)).toBe(true);
      expect(n1.sign()).toBe(1);
      expect(n1.sign(true)).toBe(1);
      expect(n1.sign(false).equals(mathJS.Number["new"](1))).toBe(true);
      expect(n4.sign()).toBe(-1);
      expect(n4.sign(false).equals(mathJS.Number["new"](-1))).toBe(true);
      expect(n1.negate().equals(-4)).toBe(true);
      return expect(n4.negate().equals(42)).toBe(true);
    });
    return it("conversion", function() {
      var n1, n2, n3;
      n1 = mathJS.Number["new"](0.8);
      n2 = mathJS.Number["new"](1e-14);
      n3 = mathJS.Number["new"](1e-5);
      expect(n1.toString()).toBe("0.8");
      expect(n2.toString()).toBe("1e-14");
      expect(n2.toString("0.00000000000000000000")).toBe("0.00000000000001000000");
      expect(n3.toString()).toBe("0.00001");
      expect(n1.toNumber().equals(n1)).toBe(true);
      return expect(n1.toInt().equals(mathJS.Int["new"](n1))).toBe(true);
    });
  });

  describe("Number (reals)", function() {
    it("creation", function() {
      expect(mathJS.Number["new"](12).value).toBe(12);
      return expect(mathJS.Number.parse("12e-2").equals(mathJS.Number["new"](0.12))).toBe(true);
    });
    it("comparison", function() {
      var n1, n2;
      n1 = mathJS.Number["new"](42);
      n2 = mathJS.Number["new"](1337.123);
      expect(mathJS.Number["new"](42).equals(n1)).toBe(true);
      expect(n1.lessThan(n2)).toBe(true);
      expect(n1.greaterThan(n2)).toBe(false);
      expect(n2.lessThan(n1)).toBe(false);
      expect(n2.greaterThan(n1)).toBe(true);
      expect(n1.lessThanOrEqualTo(n1)).toBe(true);
      expect(n1.greaterThanOrEqualTo(n1)).toBe(true);
      expect(n1.lessThanOrEqualTo(n2)).toBe(true);
      expect(n1.greaterThanOrEqualTo(n2)).toBe(false);
      expect(n2.lessThanOrEqualTo(n1)).toBe(false);
      return expect(n2.greaterThanOrEqualTo(n1)).toBe(true);
    });
    it("basic operations", function() {
      var diff, n1, n2, product, quotient, sum;
      n1 = mathJS.Number["new"](4);
      n2 = mathJS.Number["new"](5);
      sum = mathJS.Number["new"](9);
      diff = mathJS.Number["new"](-1);
      product = mathJS.Number["new"](20);
      quotient = mathJS.Number["new"](0.8);
      expect(n1.plus(n2).equals(9)).toBe(true);
      expect(n1.plus(n2).equals(sum)).toBe(true);
      expect(n1.minus(n2).equals(-1)).toBe(true);
      expect(n1.minus(n2).equals(diff)).toBe(true);
      expect(n1.times(n2).equals(20)).toBe(true);
      expect(n1.times(n2).equals(product)).toBe(true);
      expect(n1.divide(n2).equals(0.8)).toBe(true);
      return expect(n1.divide(n2).equals(quotient)).toBe(true);
    });
    it("advanced operations", function() {
      var cube, curt, n1, n2, n3, n4, pow, reciprocal, root, sign, sqrt, square;
      n1 = mathJS.Number["new"](4);
      n2 = mathJS.Number["new"](8);
      n3 = mathJS.Number["new"](625);
      n4 = mathJS.Number["new"](-42);
      square = mathJS.Number["new"](16);
      cube = mathJS.Number["new"](64);
      sqrt = mathJS.Number["new"](2);
      curt = mathJS.Number["new"](2);
      root = mathJS.Number["new"](5);
      reciprocal = mathJS.Number["new"](1 / 8);
      pow = mathJS.Number["new"](625);
      sign = mathJS.Number["new"](1);
      expect(n1.square().equals(16)).toBe(true);
      expect(n1.square().equals(square)).toBe(true);
      expect(n1.cube().equals(64)).toBe(true);
      expect(n1.cube().equals(cube)).toBe(true);
      expect(n1.sqrt().equals(2)).toBe(true);
      expect(n1.sqrt().equals(sqrt)).toBe(true);
      expect(n2.curt().equals(2)).toBe(true);
      expect(n2.curt().equals(curt)).toBe(true);
      expect(n3.root(4).equals(5)).toBe(true);
      expect(n3.root(mathJS.Number["new"](4)).equals(root)).toBe(true);
      expect(n2.reciprocal().equals(0.125)).toBe(true);
      expect(n2.reciprocal().equals(reciprocal)).toBe(true);
      expect(n1.pow(4).root(4).equals(n1)).toBe(true);
      expect(n2.pow(mathJS.Number["new"](8)).root(8).equals(n2)).toBe(true);
      expect(n1.sign()).toBe(1);
      expect(n1.sign(true)).toBe(1);
      expect(n1.sign(false).equals(mathJS.Number["new"](1))).toBe(true);
      expect(n4.sign()).toBe(-1);
      expect(n4.sign(false).equals(mathJS.Number["new"](-1))).toBe(true);
      expect(n1.negate().equals(-4)).toBe(true);
      return expect(n4.negate().equals(42)).toBe(true);
    });
    return it("conversion", function() {
      var n1, n2, n3;
      n1 = mathJS.Number["new"](0.8);
      n2 = mathJS.Number["new"](1e-14);
      n3 = mathJS.Number["new"](1e-5);
      expect(n1.toString()).toBe("0.8");
      expect(n2.toString()).toBe("1e-14");
      expect(n2.toString("0.00000000000000000000")).toBe("0.00000000000001000000");
      expect(n3.toString()).toBe("0.00001");
      expect(n1.toNumber().equals(n1)).toBe(true);
      return expect(n1.toInt().equals(mathJS.Int["new"](n1))).toBe(true);
    });
  });

  describe("Domains", function() {
    it("N", function() {
      var set;
      set = mathJS.Domains.N;
      expect(set.size()).toBe(Infinity);
      expect(set.contains(0)).toBe(true);
      expect(set.contains(0.5)).toBe(false);
      expect(set.contains(-5)).toBe(false);
      expect(set.infimum).toBe(0);
      return expect(set.supremum).toBe(Infinity);
    });
    it("Z", function() {
      var set;
      set = mathJS.Domains.Z;
      expect(set.size()).toBe(Infinity);
      expect(set.contains(0)).toBe(true);
      expect(set.contains(0.5)).toBe(false);
      expect(set.contains(-5)).toBe(true);
      expect(set.infimum).toBe(Infinity);
      return expect(set.supremum).toBe(Infinity);
    });
    it("Q", function() {
      var set;
      set = mathJS.Domains.Q;
      expect(set.size()).toBe(Infinity);
      expect(set.contains(0)).toBe(true);
      expect(set.contains(0.5)).toBe(true);
      expect(set.contains(-5)).toBe(true);
      expect(set.infimum).toBe(Infinity);
      return expect(set.supremum).toBe(Infinity);
    });
    it("I", function() {
      var set;
      set = mathJS.Domains.I;
      expect(set.size()).toBe(Infinity);
      expect(set.contains(0)).toBe(true);
      expect(set.contains(0.5)).toBe(false);
      expect(set.contains(-5)).toBe(true);
      expect(set.contains(mathJS.pi)).toBe(true);
      expect(set.infimum).toBe(Infinity);
      return expect(set.supremum).toBe(Infinity);
    });
    return it("R", function() {
      var set;
      set = mathJS.Domains.R;
      expect(set.size()).toBe(Infinity);
      expect(set.contains(0)).toBe(true);
      expect(set.contains(0.5)).toBe(true);
      expect(set.contains(-5)).toBe(true);
      expect(set.contains(mathJS.pi)).toBe(true);
      expect(set.infimum).toBe(Infinity);
      return expect(set.supremum).toBe(Infinity);
    });
  });

  describe("Sets", function() {
    return describe("should be able be parsed from string:", function() {
      it("ellipsis", function() {
        var set;
        set = mathJS.Set.fromString("{1, 2, 3, ...}");
        return expect(set.size()).toBe(Infinity);
      });
      return it("simple expression (variable) + domain", function() {
        var set, set2;
        set = mathJS.Set.fromString("{ x | x in R}");
        expect(set.size()).toBe(Infinity);
        set2 = mathJS.Set.fromString("{ x : x in R}");
        return expect(set.size()).toBe(Infinity);
      });
    });
  });

}).call(this);
